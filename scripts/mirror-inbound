#!/usr/bin/python
#
# Copyright (c) 2005-2009 rPath, Inc.
#
# All Rights Reserved
#

import logging
import sys

from conary import versions
from conary import conarycfg
from conary.conaryclient import mirror
from conary.repository import errors
from conary import conaryclient

from mint.client import MintClient
from mint.scripts.mirror import MirrorScript

log = logging.getLogger(__name__)


class MirrorInbound(MirrorScript):
    logFileName = "mirror-inbound.log"
    options = None

    def action(self):
        self.resetLogging()
        client = MintClient(self.mintUrl)
        cfg = mirror.MirrorConfiguration()

        proxy = self.cfg.proxy

        mirroredLabels = client.getInboundMirrors()

        for label in mirroredLabels:
            inboundMirrorId, targetProjectId, sourceLabels, sourceUrl, \
                    sourceAuthType, sourceUser, sourcePass, \
                    sourceEntitlement, mirrorOrder, allLabels = label
            targetProject = client.getProject(targetProjectId)
            log.info("Mirroring %s", targetProject.name)

            try:
                targetLabelId = targetProject.getLabelIdMap().values()[0]
                labelInfo = client.getLabel(targetLabelId)
                reposHost = versions.Label(labelInfo['label']).getHost()

                if self.cfg.SSL and labelInfo['url'].startswith('http:'):
                    labelInfo['url'] = "https" + labelInfo['url'][4:]

                cfg.source.repositoryMap.update(client.getFullRepositoryMap())
                cfg.source.repositoryMap.update({reposHost: sourceUrl})
                if sourceAuthType == 'userpass':
                    cfg.source.user.addServerGlob(reposHost, sourceUser, sourcePass)
                elif sourceAuthType == 'entitlement':
                    cfg.source.entitlement.addEntitlement(reposHost, sourceEntitlement)

                cfg.target.repositoryMap.update(cfg.source.repositoryMap)
                cfg.target.repositoryMap.update({reposHost: labelInfo['url']})
                if labelInfo['authType'] == 'userpass':
                    cfg.target.user.addServerGlob(reposHost, labelInfo['username'], labelInfo['password'])
                elif labelInfo['authType'] == 'entitlement':
                    cfg.target.entitlement.addEntitlement(reposHost, labelInfo['entitlement'])

                cfg.host = reposHost
                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(x) for x in sourceLabels.split()]
                sourceCCfg = conarycfg.ConaryConfiguration()
                sourceCCfg.repositoryMap.update(cfg.source.repositoryMap)
                sourceCCfg.user = cfg.source.user
                sourceCCfg.entitlement = cfg.source.entitlement
                sourceCCfg.proxy = proxy
                sourceRepos = conaryclient.ConaryClient(sourceCCfg).getRepos()

                targetCCfg = conarycfg.ConaryConfiguration()
                targetCCfg.repositoryMap.update(cfg.target.repositoryMap)
                targetCCfg.user = cfg.target.user
                targetCCfg.entitlement = cfg.target.entitlement
                targetRepos = conaryclient.ConaryClient(targetCCfg).getRepos()

                self._doMirror(cfg, sourceRepos, targetRepos)
            except KeyboardInterrupt:
                log.info("Inbound mirror killed by user")
                break
            except errors.InsufficientPermission, ie:
                log.error("%s. Check to make sure that you have been given access to mirror from the aforementioned repository.", ie)
            except:
                log.exception("Unhandled exception while mirroring %s",
                        targetProject.name)

        return 0

    def cleanup(self):
        log.info("Inbound mirror script finished")

if __name__ == "__main__":
    mi = MirrorInbound()
    sys.exit(mi.run())

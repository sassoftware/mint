#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

import sys
import os
from os import _exit

from conary import versions
from conary import conarycfg
from conary.conaryclient import mirror
from conary.lib import util, log
from conary import conaryclient

from mint import config
from mint import helperfuncs
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorInbound(MirrorScript):
    logFileName = "mirror-inbound.log"
    options = None

    def action(self):
        client = MintClient(self.args[0])
        cfg = mirror.MirrorConfiguration()
        cfg.entitlementDirectory = self.cfg.dataPath + '/entitlements/'

        proxy = self.cfg.proxy

        mirroredLabels = client.getInboundMirrors()

        for label in mirroredLabels:
            inboundMirrorId, targetProjectId, sourceLabels, sourceUrl, \
                    sourceUser, sourcePass, allLabels = label
            targetProject = client.getProject(targetProjectId)
            self.log.info("Mirroring %s" % targetProject.name)

            try:
                targetLabelId = targetProject.getLabelIdMap().values()[0]
                targetLabelStr, targetUrl, targetUser, targetPass = client.getLabel(targetLabelId)
                reposHost = versions.Label(targetLabelStr).getHost()

                if self.cfg.SSL and targetUrl.startswith('http:'):
                    targetUrl = "https" + targetUrl[4:]

                cfg.source.repositoryMap.update(client.getFullRepositoryMap())
                cfg.source.repositoryMap.update({reposHost: sourceUrl})
                if sourceUser:
                    cfg.source.user.addServerGlob(reposHost, sourceUser, sourcePass)

                cfg.target.repositoryMap.update(cfg.source.repositoryMap)
                cfg.target.repositoryMap.update({reposHost: targetUrl})
                cfg.target.user.addServerGlob(reposHost, targetUser, targetPass)

                cfg.host = reposHost
                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(x) for x in sourceLabels.split()]

                sourceCfg = conarycfg.ConaryConfiguration()
                sourceCfg.repositoryMap.update(cfg.source.repositoryMap)
                sourceCfg.user = cfg.source.user
                sourceCfg.entitlementDirectory = cfg.entitlementDirectory
                sourceCfg.readEntitlementDirectory()
                sourceCfg.proxy = proxy
                sourceRepos = conaryclient.ConaryClient(sourceCfg).getRepos()

                targetCfg = conarycfg.ConaryConfiguration()
                targetCfg.repositoryMap.update(cfg.target.repositoryMap)
                targetCfg.user = cfg.target.user
                targetCfg.entitlementDirectory = cfg.entitlementDirectory
                targetCfg.readEntitlementDirectory()
                targetCfg.proxy = proxy
                targetRepos = conaryclient.ConaryClient(targetCfg).getRepos()

                self._doMirror(cfg, sourceRepos, targetRepos)

            except Exception, e:
                self.log.error("Exception occurred mirroring %s" % targetProject.name)
                self.logTraceback()

        return 0

    def cleanup(self):
        self.log.info("Inbound mirror script finished")

if __name__ == "__main__":
    mi = MirrorInbound()
    _exit(mi.run())

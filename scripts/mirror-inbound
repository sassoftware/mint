#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

import sys
import os
from os import _exit

from conary import versions
from conary import conarycfg
from conary.conaryclient import mirror
from conary.lib import util, log
from conary import conaryclient

from mint import config
from mint import helperfuncs
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorInbound(MirrorScript):
    logFileName = "mirror-inbound.log"
    options = None

    def action(self):
        self.resetLogging()
        client = MintClient(self.args[0])
        cfg = mirror.MirrorConfiguration()

        proxy = self.cfg.proxy

        mirroredLabels = client.getInboundMirrors()

        for label in mirroredLabels:
            inboundMirrorId, targetProjectId, sourceLabels, sourceUrl, \
                    sourceAuthType, sourceUser, sourcePass, \
                    sourceEntitlement, allLabels = label
            targetProject = client.getProject(targetProjectId)
            self.log.info("Mirroring %s" % targetProject.name)

            try:
                targetLabelId = targetProject.getLabelIdMap().values()[0]
                labelInfo = client.getLabel(targetLabelId)
                reposHost = versions.Label(labelInfo['label']).getHost()

                if self.cfg.SSL and labelInfo['url'].startswith('http:'):
                    labelInfo['url'] = "https" + labelInfo['url'][4:]

                cfg.source.repositoryMap.update(client.getFullRepositoryMap())
                cfg.source.repositoryMap.update({reposHost: sourceUrl})
                if sourceAuthType == 'userpass':
                    cfg.source.user.addServerGlob(reposHost, sourceUser, sourcePass)
                elif sourceAuthType == 'entitlement':
                    cfg.source.entitlement.addEntitlement(reposHost, sourceEntitlement)

                cfg.target.repositoryMap.update(cfg.source.repositoryMap)
                cfg.target.repositoryMap.update({reposHost: labelInfo['url']})
                if labelInfo['authType'] == 'userpass':
                    cfg.target.user.addServerGlob(reposHost, labelInfo['username'], labelInfo['password'])
                elif labelInfo['authType'] == 'entitlement':
                    cfg.target.entitlement.addEntitlement(reposHost, labelInfo['entitlement'])

                cfg.host = reposHost
                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(x) for x in sourceLabels.split()]

                sourceRepos = netclient.NetworkRepositoryClient(cfg.source.repositoryMap,
                                          cfg.source.user, proxy = proxy)

                targetRepos = netclient.NetworkRepositoryClient(cfg.target.repositoryMap,
                                          cfg.target.user)


                self._doMirror(cfg, sourceRepos, targetRepos)
            except KeyboardInterrupt, ke:
                self.log.info("Inbound mirror killed by user")
                break
            except errors.InsufficientPermission, ie:
                self.log.error("%s. Check to make sure that you have been given access to mirror from the aforementioned repository." % ie)
            except Exception, e:
                self.log.error("Exception occurred while mirroring %s" % targetProject.name)
                self.logTraceback()

        return 0

    def cleanup(self):
        self.log.info("Inbound mirror script finished")

if __name__ == "__main__":
    mi = MirrorInbound()
    _exit(mi.run())

#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

import sys
import os
from os import _exit

from conary import versions
from conary.conaryclient import mirror
from conary.lib import util, log
from conary.repository import netclient

from mint import config
from mint import helperfuncs
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorInbound(MirrorScript):
    logFileName = "mirror-inbound.log"
    options = None

    def action(self):
        mintCfg = config.MintConfig()
        mintCfg.read(config.RBUILDER_CONFIG)

        client = MintClient(self.args[0])
        cfg = mirror.MirrorConfiguration()
        cfg.entitlementDirectory = mintCfg.dataPath + '/entitlements/'

        proxy = mintCfg.proxy

        mirroredLabels = client.getInboundMirrors()

        for label in mirroredLabels:
            inboundMirrorId, targetProjectId, sourceLabels, sourceUrl, \
                    sourceUser, sourcePass, allLabels = label
            targetProject = client.getProject(targetProjectId)
            self.log.info("Mirroring %s" % targetProject.name)

            try:
                targetLabelId = targetProject.getLabelIdMap().values()[0]
                targetLabelStr, targetUrl, targetUser, targetPass = client.getLabel(targetLabelId)
                reposHost = versions.Label(targetLabelStr).getHost()

                if mintCfg.SSL and targetUrl.startswith('http:'):
                    targetUrl = "https" + targetUrl[4:]

                cfg.source.repositoryMap = client.getFullRepositoryMap()
                cfg.source.repositoryMap.update({reposHost: sourceUrl})
                if sourceUser:
                    cfg.source.user.addServerGlob(reposHost, sourceUser, sourcePass)

                cfg.target.repositoryMap = cfg.source.repositoryMap.copy()
                cfg.target.repositoryMap.update({reposHost: targetUrl})
                cfg.target.user.addServerGlob(reposHost, targetUser, targetPass)

                cfg.host = reposHost
                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(x) for x in sourceLabels.split()]

                sourceRepos = netclient.NetworkRepositoryClient(cfg.source.repositoryMap,
                                          cfg.source.user,
                                          entitlementDir = cfg.entitlementDirectory,
                                          proxy = proxy)

                targetRepos = netclient.NetworkRepositoryClient(cfg.target.repositoryMap,
                                          cfg.target.user,
                                          entitlementDir = cfg.entitlementDirectory)


                self._doMirror(cfg, sourceRepos, targetRepos)

            except Exception, e:
                self.log.error("Exception occurred mirroring %s" % targetProject.name)
                self.logTraceback()

        return 0

    def cleanup(self):
        self.log.info("Inbound mirror script finished")

if __name__ == "__main__":
    mi = MirrorInbound()
    _exit(mi.run())

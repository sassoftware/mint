#!/usr/bin/python2.4
#
# Copyright (c) 2006 rPath, Inc.
#
# All Rights Reserved
#

# This script will compile an sqlite mirror of a repository and split the
# contents into ISO's of user definable size.

import os, sys
import tempfile
import signal
import time
import socket
import subprocess
from math import ceil

from conary.conaryclient import mirror
from conary import versions
from conary.repository import netclient
from conary.repository.netrepos import netserver
from conary.lib import util, log
from conary.server import schema
from conary.server import server
from conary import dbstore
from conary.repository import errors

from mint.scriptlibrary import SingletonScript

log.setVerbosity(log.DEBUG)

MAX_FILESIZE = 1000000000

class MirrorOffline(SingletonScript):

    def handle_args(self):
        if len(sys.argv) < 3:
            return False
        return True

    def usage(self):
        print "usage: %s <url to repository> <label> <mirrorDir> <username> <password> [ISO size]" % self.name
        return 1

    def action(self):
        try:
            pid = 0
            outputDir = tempfile.mkdtemp(prefix = os.path.join(os.getcwd(),
                                                               'tmp'))
            if len(sys.argv) < 6:
                return self.usage()
            cfg = mirror.MirrorConfiguration()

            sourceUrl, labelStr, baseDir, userName, userPass = sys.argv[1:6]
            util.mkdirChain(baseDir)

            labelStr = sys.argv[2]
            if len(sys.argv) > 6:
                if sys.argv[6][-1].isalpha():
                    sizeBase = float(sys.argv[6][:-1])
                    mult = {'B' : 1,
                            'b' : 1,
                            'K' : 1024,
                            'k' : 1000,
                            'M' : 1048576,
                            'm' : 1000000,
                            'G' : 1073741824,
                            'g' : 1000000000}[sys.argv[6][-1]]
                else:
                    sizeBase = float(sys.argv[6])
                    mult = 1048576
                isoSize = int(mult * sizeBase)
            else:
                # default is a 650MB CD
                isoSize = 681574400
            # round down to an iso-block sized limit.
            # adjust for disc formatting data
            isoSize -= isoSize % 2048
            # 174 iso blocks plus 3/4 of an isoblock per file, rounded up.
            numFiles = (isoSize / (MAX_FILESIZE * 1.0))
            resBlocks = (174 + numFiles + 1) + ceil((numFiles * 2 + 1) * 0.75)
            isoSize -= resBlocks * 2048

            openPort = 21213
            while True:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                try:
                    sock.connect((("127.0.0.1"), openPort))
                    openPort += 1
                except:
                    break;
            sock.close()

            # instantiate a target repository right here.
            targCfg = netserver.ServerConfig()
            targCfg.serverName = versions.Label(labelStr).getHost()
            targCfg.port = openPort
            targetUrl="http://%s:%d/" % ('127.0.0.1', targCfg.port)
            targCfg.contentsDir = os.path.join(baseDir, 'contents')
            targCfg.repositoryDB = ('sqlite', os.path.join(baseDir, 'sqldb'))
            db = dbstore.connect(targCfg.repositoryDB[1],
                                 targCfg.repositoryDB[0])
            schema.loadSchema(db)
            netRepos = netserver.NetworkRepositoryServer(targCfg, targetUrl)

            try:
                netRepos.auth.addUser(userName, userPass)
                netRepos.auth.addAcl(userName, None, None, True, False, True)
                netRepos.auth.setMirror(userName, True)
            except errors.GroupAlreadyExists:
                # assume user is already present--probably due to a previous
                # run being aborted.
                pass

            pid = os.fork()
            if not pid:
                fd = os.open(os.devnull, os.W_OK)
                os.dup2(fd, sys.stdout.fileno())
                os.dup2(fd, sys.stderr.fileno())
                os.close(fd)
                os.system("python %s --contents-dir %s --db '%s %s' --port %d"
                          " --server-name %s"
                          % (server.__file__, targCfg.contentsDir,
                             targCfg.repositoryDB[0], targCfg.repositoryDB[1],
                             targCfg.port, targCfg.serverName))

            sock = socket.socket()
            count = 500;
            while count:
                try:
                    sock.connect((("127.0.0.1"), targCfg.port))
                    break
                except:
                    time.sleep(0.01)
                count -= 1
            if not count:
                raise SystemError, "unable to contact repository server"
            else:
                sock.close()

            reposHost = versions.Label(labelStr).getHost()

            cfg.target.repositoryMap = {reposHost: targetUrl}
            cfg.target.user.addServerGlob(reposHost, userName, userPass)

            cfg.source.repositoryMap = {reposHost: sourceUrl}
            cfg.source.user.addServerGlob(reposHost, userName, userPass)

            cfg.host = reposHost
            cfg.labels = [versions.Label(labelStr)]

            targetRepos = netclient.NetworkRepositoryClient( \
                cfg.target.repositoryMap, cfg.target.user,
                entitlementDir = cfg.entitlementDirectory)

            sourceRepos = netclient.NetworkRepositoryClient( \
                cfg.source.repositoryMap, cfg.source.user,
                entitlementDir = cfg.entitlementDirectory)

            while mirror.mirrorRepository(sourceRepos, targetRepos, cfg,
                                          False, False, False):
                pass

            # clear the account we just used.
            targetRepos.deleteUserByName(versions.Label(labelStr), userName)

            #count the target files on the disc
            numFilePipe = os.popen('find %s -not -type d | grep -c ""' % \
                                   baseDir, 'r')
            numFiles = int(numFilePipe.read().strip())
            numFilePipe.close()

            # bundle the results
            util.execute('tar -C %s -cpPsv -O ./ | split -a 3 -d -b %d - %s' %\
                         (baseDir, isoSize,
                          os.path.join(outputDir, "mirror-" + targCfg.serverName + '.tgz')))

            # break DVD's into multi-part files. to comply with ISO-9660/UDF
            # filesystem constraints
            if isoSize > MAX_FILESIZE:
                splitFiles = os.listdir(outputDir)
                numDiscs = len(splitFiles)
                for curDisc, fn in [(x[0] + 1, x[1]) for x in \
                                    enumerate(sorted(os.listdir(outputDir)))]:
                    createKeyFile(targCfg.serverName, curDisc, numDiscs,
                                  numFiles, outputDir)
                    util.execute("split -a 3 -d -b %d %s %s" % \
                                 (MAX_FILESIZE, os.path.join(outputDir, fn),
                                  os.path.join(outputDir, fn + '_')))

                    files = " ".join([os.path.join(outputDir, x) \
                                      for x in os.listdir(outputDir) \
                                      if x.startswith(fn + '_')])
                    for splitFile in [x for x \
                                      in os.listdir(outputDir) \
                                      if x.startswith(fn + '_')]:
                        shaName = splitFile + '.sha1'
                        shaFile = open(os.path.join(outputDir, shaName), 'w')
                        pipe = os.popen('sha1sum %s' % \
                               os.path.join(outputDir, splitFile))
                        shaFile.write(pipe.read().split()[0])
                        shaFile.close()
                        files += " " + os.path.join(outputDir, shaName)
                    files += " " + os.path.join(outputDir, "MIRROR-INFO")
                    util.execute("mkisofs -o %s -r -U %s" % \
                                 (os.path.join( \
                        outputDir, fn.replace('.tgz', '') + '.iso'), files))
            else:
                numDiscs = len(os.listdir(outputDir))
                for curDisc, fn in [(x[0] + 1, x[1]) for x in \
                                    enumerate(sorted(os.listdir(outputDir)))]:
                    shaFile = open(os.path.join(outputDir, fn) + ".sha1", "w")
                    pipe = os.popen('sha1sum %s' % \
                                    os.path.join(outputDir, fn))
                    shaFile.write(pipe.read().split()[0])
                    shaFile.close()
                    createKeyFile(targCfg.serverName, curDisc, numDiscs,
                                  numFiles, outputDir)
                    files = [fn, fn + ".sha1", "MIRROR-INFO"]
                    util.execute("mkisofs -o %s -r -U %s" % \
                                 (os.path.join( \
                        outputDir, fn.replace('.tgz', '') + '.iso'),
                                  " ".join(os.path.join(outputDir, x) for x in files)))
            for isoFile in [f for f in os.listdir(outputDir) if f.endswith('.iso')]:
                os.rename(os.path.join(outputDir, isoFile),
                          os.path.join('.', isoFile))
        finally:
	    try:
                util.rmtree(outputDir)
            except:
                pass
            try:
                # attempt to clear the account in case an exception occured
                targetRepos.deleteUserByName(versions.Label(labelStr),
                                             userName)
            except:
                pass
        return 0


def createKeyFile(serverName, curDisc, numDiscs, numFiles, outputDir):
    keyFile = open(os.path.join(outputDir, "MIRROR-INFO"), "w")
    print >> keyFile, "%s" % serverName
    print >> keyFile, "%d/%d" % (curDisc, numDiscs)
    print >> keyFile, "%d" % numFiles
    keyFile.close()


if __name__ == "__main__":
    mo = MirrorOffline()
    os._exit(mo.run())

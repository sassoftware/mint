#!/usr/bin/python
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

# This script will compile an sqlite mirror of a repository and split the
# contents into ISO's of user definable size.

import os, sys
import tempfile
import signal
import time
import socket
import subprocess
from math import ceil
from mint import helperfuncs

from conary.conaryclient import mirror
from conary import versions
from conary.repository import netclient
from conary.repository.netrepos import netserver
from conary.lib import util, log
from conary.server import schema
from conary.server import server
from conary import dbstore
from conary.repository import errors

from mint.lib.scriptlibrary import SingletonScript

log.setVerbosity(log.DEBUG)

MAX_FILESIZE = 1000000000

class MirrorOffline(SingletonScript):

    def handle_args(self):
        if len(sys.argv) < 3:
            return False
        return True

    def usage(self):
        print "usage: %s <url to repository> <label> <mirrorDir> <username> <password> [ISO size]" % self.name
        return 1

    def action(self):
        try:
            pid = 0
            outputDir = tempfile.mkdtemp(prefix = os.path.join(os.getcwd(),
                                                               'tmp'))
            if len(sys.argv) < 6:
                return self.usage()
            cfg = mirror.MirrorConfiguration()

            sourceUrl, labelStr, baseDir, userName, userPass = sys.argv[1:6]
            util.mkdirChain(baseDir)

            labelStr = sys.argv[2]
            if len(sys.argv) > 6:
                if sys.argv[6][-1].isalpha():
                    sizeBase = float(sys.argv[6][:-1])
                    mult = {'B' : 1,
                            'b' : 1,
                            'K' : 1024,
                            'k' : 1000,
                            'M' : 1048576,
                            'm' : 1000000,
                            'G' : 1073741824,
                            'g' : 1000000000}[sys.argv[6][-1]]
                else:
                    sizeBase = float(sys.argv[6])
                    mult = 1048576
                isoSize = int(mult * sizeBase)
            else:
                # default is a 650MB CD
                isoSize = 681574400
            # round down to an iso-block sized limit.
            # adjust for disc formatting data
            if isoSize:
                isoSize -= isoSize % 2048
                numFiles = ceil(isoSize / (MAX_FILESIZE * 1.0))
                resBlocks = (173 + numFiles + 1) + ceil((numFiles * 2 + 1) * 0.50)
                isoSize -= int(resBlocks) * 2048
            else:
                outputDir = baseDir

            openPort = 21213
            while True:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                try:
                    sock.connect((("127.0.0.1"), openPort))
                    openPort += 1
                except:
                    break;
            sock.close()

            # instantiate a target repository right here.
            targCfg = netserver.ServerConfig()
            targCfg.serverName = versions.Label(labelStr).getHost()
            targCfg.port = openPort
            targetUrl="http://%s:%d/" % ('127.0.0.1', targCfg.port)
            targCfg.contentsDir = os.path.join(baseDir, 'contents')
            targCfg.repositoryDB = ('sqlite', os.path.join(baseDir, 'sqldb'))
            db = dbstore.connect(targCfg.repositoryDB[1],
                                 targCfg.repositoryDB[0])
            util.mkdirChain(os.path.join(baseDir, 'tmp'))
            schema.loadSchema(db)
	    # FIXME: can we get this to use the reposmgr interface?
	    # We'd need to have the ability to add extra roles/users.
            netRepos = netserver.NetworkRepositoryServer(targCfg, targetUrl)

	    try:
		repos.auth.addRole(role)
	    except RoleAlreadyExists:
		# who cares
		pass
	    netRepos.auth.addAcl(userName, None, None, 
				 write=True, remove=False)
	    netRepos.auth.addUser(username, password)
	    netRepos.auth.addRoleMember(role, username)
	    netRepos.auth.setAdmin(userName, True)
	    netRepos.auth.setMirror(userName, True)

            pid = os.fork()
            if not pid:
                fd = os.open(os.devnull, os.W_OK)
                os.dup2(fd, sys.stdout.fileno())
                os.dup2(fd, sys.stderr.fileno())
                os.close(fd)
                os.execlp("python", "python", server.__file__,
                          "--contents-dir",
                          targCfg.contentsDir, "--db",
                          '%s %s' % (targCfg.repositoryDB[0],
                                     targCfg.repositoryDB[1]),
                          "--port", str(targCfg.port),
                          "--server-name", targCfg.serverName)

            sock = socket.socket()
            count = 500;
            while count:
                try:
                    sock.connect((("127.0.0.1"), targCfg.port))
                    break
                except:
                    time.sleep(0.01)
                count -= 1
            if not count:
                raise SystemError, "unable to contact repository server"
            else:
                sock.close()

            reposHost = versions.Label(labelStr).getHost()

            cfg.target.repositoryMap = {reposHost: targetUrl}
            cfg.target.user.addServerGlob(reposHost, userName, userPass)

            cfg.source.repositoryMap = {reposHost: sourceUrl}
            cfg.source.user.addServerGlob(reposHost, userName, userPass)

            cfg.host = reposHost
            cfg.labels = [versions.Label(labelStr)]

            targetRepos = netclient.NetworkRepositoryClient( \
                cfg.target.repositoryMap, cfg.target.user,
                entitlementDir = cfg.entitlementDirectory)

            sourceRepos = netclient.NetworkRepositoryClient( \
                cfg.source.repositoryMap, cfg.source.user,
                entitlementDir = cfg.entitlementDirectory)

            while mirror.mirrorRepository(sourceRepos, targetRepos, cfg,
                                          False, False, False):
                pass

            # clear the account we just used.
            targetRepos.deleteUserByName(versions.Label(labelStr), userName)

            #count the target files on the disc
            numFilePipe = os.popen('find %s -not -type d | grep -c ""' % \
                                   baseDir, 'r')
            numFiles = int(numFilePipe.read().strip())
            numFilePipe.close()

            if isoSize == 0:
                print "ISO size set to 0: not creating ISOs"
                createKeyFile(targCfg.serverName, 0, 0, numFiles, outputDir)
            else:
                # bundle the results
                util.execute('tar -C %s -cpPsv -O ./ | split -a 3 -d -b %d - %s' %\
                             (baseDir, isoSize,
                              os.path.join(outputDir, "mirror-" + targCfg.serverName + '.tar')))

                # break DVD's into multi-part files. to comply with ISO-9660/UDF
                # filesystem constraints
                if isoSize > MAX_FILESIZE:
                    splitFiles = os.listdir(outputDir)
                    numDiscs = len(splitFiles)
                    for curDisc, fn in [(x[0] + 1, x[1]) for x in \
                                        enumerate(sorted(os.listdir(outputDir)))]:
                        createKeyFile(targCfg.serverName, curDisc, numDiscs,
                                      numFiles, outputDir)
                        util.execute("split -a 3 -d -b %d %s %s" % \
                                     (MAX_FILESIZE, os.path.join(outputDir, fn),
                                      os.path.join(outputDir, fn + '_')))

                        files = " ".join([os.path.join(outputDir, x) \
                                          for x in os.listdir(outputDir) \
                                          if x.startswith(fn + '_')])
                        for splitFile in [x for x \
                                          in os.listdir(outputDir) \
                                          if x.startswith(fn + '_')]:
                            shaName = splitFile + '.sha1'
                            shaFile = open(os.path.join(outputDir, shaName), 'w')
                            pipe = os.popen('sha1sum %s' % \
                                   os.path.join(outputDir, splitFile))
                            shaFile.write(pipe.read().split()[0])
                            shaFile.close()
                            files += " " + os.path.join(outputDir, shaName)
                        files += " " + os.path.join(outputDir, "MIRROR-INFO")
                        util.execute("mkisofs -o %s -r -U %s" % \
                                     (os.path.join( \
                            outputDir, fn.replace('.tar', '') + '.iso'), files))
                else:
                    numDiscs = len(os.listdir(outputDir))
                    for curDisc, fn in [(x[0] + 1, x[1]) for x in \
                                        enumerate(sorted(os.listdir(outputDir)))]:
                        shaFile = open(os.path.join(outputDir, fn) + ".sha1", "w")
                        pipe = os.popen('sha1sum %s' % \
                                        os.path.join(outputDir, fn))
                        shaFile.write(pipe.read().split()[0])
                        shaFile.close()
                        createKeyFile(targCfg.serverName, curDisc, numDiscs,
                                      numFiles, outputDir)
                        files = [fn, fn + ".sha1", "MIRROR-INFO"]
                        util.execute("mkisofs -o %s -r -U %s" % \
                                     (os.path.join( \
                            outputDir, fn.replace('.tar', '') + '.iso'),
                                      " ".join(os.path.join(outputDir, x) for x in files)))
                for isoFile in [f for f in os.listdir(outputDir) if f.endswith('.iso')]:
                    os.rename(os.path.join(outputDir, isoFile),
                              os.path.join('.', isoFile))
        finally:
            try:
                if isoSize > 0:
                    util.rmtree(outputDir)
                else:
                    print "Results in %s" % outputDir
            except:
                pass
            try:
                # attempt to clear the account in case an exception occurred
                targetRepos.deleteUserByName(versions.Label(labelStr),
                                             userName)
            except:
                pass
            if pid:
                os.kill(pid, signal.SIGTERM)
                os.waitpid(pid, 0)
        return 0


def createKeyFile(serverName, curDisc, numDiscs, numFiles, outputDir):
    keyFile = open(os.path.join(outputDir, "MIRROR-INFO"), "w")
    print >> keyFile, "%s" % serverName
    print >> keyFile, "%d/%d" % (curDisc, numDiscs)
    print >> keyFile, "%d" % numFiles
    keyFile.close()


if __name__ == "__main__":
    mo = MirrorOffline()
    os._exit(mo.run())

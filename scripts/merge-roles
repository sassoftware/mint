#!/usr/bin/python
#
# Copyright (c) 2007 rPath, Inc.
#
# All Rights Reserved
#

import os
import random
import sys
import traceback

sys.path.insert(0, '/srv/code/mint')
sys.path.insert(0, '/srv/code/conary')

from mint import config
from mint.db import database
from mint.rest.db import database as restDatabase

from conary import dbstore

def updateRoles(cfg):
    db = database.Database(cfg)
    restDb = restDatabase.Database(cfg, db)
    cu = db.cursor()
    # note we don't touch permissions on inbound mirrors
    cu.execute("""SELECT hostname FROM Projects WHERE external=0 ORDER BY hostname""")
    hostnames = [x[0] for x in cu.fetchall()]

    total = len(hostnames)
    for count, hostname in enumerate(hostnames):
        print "(%3d/%s) Updating project '%s' " % (count + 1, total, hostname)
	try:
	    server = restDb.productMgr.reposMgr._getRepositoryServer(hostname)
	    updateRolesForServer(cfg, server.auth)
	except Exception, e:
	    print "Failed to convert repository %s: %s" % (hostname, e)
	    traceback.print_exc()

def updateRolesForServer(cfg, auth):
    # NOTE: we're not changing anyone's permissions here.
    # We're merging roles that are exactly the same and
    # fit our standard user/developer/owner/admin role.

    # This records in python form the current state of permissions
    # for users, and the current ids of roles with entitlements
    # Since we're not actually mucking w/ acls confirming the
    # roleIds are the same should be good enough
    userPerms = _getSortedPermissions(auth)

    standardRoles = {
	                # write, rmv,   mirr,  admin
	'rb_user'      : (False, False, False, False),
	'rb_developer' : (True,  False, False, False),
	'rb_owner'     : (True,  False, True,  False), 
    }
    if cfg.projectAdmin:
         standardRoles['rb_owner'] = (True,  False, True,  True)

    # reverse diction for looking up name by permissions
    rolesByPerms = dict((x[1], x[0]) for x in standardRoles.items())

    rolesToMerge = {}
    rolesToKeep = []

    for roleName in auth.getRoleList():
	newName = _getNewRoleName(cfg, auth, roleName, rolesByPerms)
	if not newName:
	    rolesToKeep.append(roleName)
	else:
	    rolesToMerge.setdefault(newName, []).append(roleName)

    rolesToRename = {}
    for roleName, mergeRoles in rolesToMerge.items():
	if roleName not in mergeRoles:
	    # pick somebody to rename.
	    oldName = mergeRoles[0]
	    rolesToRename[roleName] = oldName
	    # this role will no longer exist
	    mergeRoles.remove(oldName)
	    if not mergeRoles:
                del rolesToMerge[roleName]
	else:
            if mergeRoles == [roleName]:
                del rolesToMerge[roleName]





    # The most tricky case is where there's a "keeper" role that matches one 
    # of our standard role names.
    # In that case we'll just rename the keeper role, as this will likely
    # never happen.
    overlapping = (set(standardRoles) | set(['rb_admin'])) & set(rolesToKeep)
    for roleName in overlapping:
	# if orig_ + role already exists, it's almost certainly
	# a rerun of this algorithm, and we'll let it error out.
	newName = 'orig_' + roleName
	rolesToRename[newName] = roleName
    if not (rolesToRename or rolesToMerge):
        return

    print "================================== "
    if rolesToRename:
	print "Roles to Rename:"
	for name, oldName in sorted(rolesToRename.items()):
	    print "   %s -> %s" % (oldName, name)
    else:
	print "Roles to Rename: None"

    if rolesToMerge:
	print "Roles to Merge:"
	for newName, mergeNames in sorted(rolesToMerge.items()):
	    print "  %s: Merge from:" % newName
	    print "       %s" % (sorted(mergeNames),)
    else:
	print "Roles to Merge: None"
    print "================================== "

    origCommit = auth.db.commit
    auth.db.commit = lambda: None
    try:
	_renameRoles(auth, rolesToRename)
	_mergeRoles(auth, rolesToMerge)
    finally:
	auth.db.commit = origCommit

    # finaly sanity check.
    finalPerms = _getSortedPermissions(auth)
    if userPerms != finalPerms:
        if sorted(userPerms.keys()) != sorted(finalPerms.keys()):
            raise RuntimeError('Permissions conversion failed - user list')
        wrongPerms = []
        for name in userPerms:
            if userPerms[name] != finalPerms[name]:
                wrongPerms.append(name)
        raise RuntimeError('Permissions conversion failed - would result in wrong permissions for %s' % (wrongPerms,))
    # sanity check passed - permissions for users have not changed.
    auth.db.commit()
 
def _getNewRoleName(cfg, auth, role, rolesByPerms):
    # returns None to not change this role 
    # otherwise return the name to merge 
    # this role with.
    if role in (cfg.authUser, 'rb_internal_admin'):
	# authUser gets their own role.
	return 'rb_internal_admin'
    allPerms = auth.getPermsByRole(role)
    if len(allPerms) != 1:
	# not a standard role.
	return None
    else:
	perms = allPerms[0]
	if perms['label'] != 'ALL' or perms['item'] != 'ALL':
	    # not a standard role.
	    return None
	write = perms['canWrite']
	remove = perms['canRemove']
	mirror = auth.roleCanMirror(role)
	admin = auth.roleIsAdmin(role)
	newName = rolesByPerms.get((write, remove, mirror, admin), None)
	return newName

def _getSortedPermissions(auth):
    """ 
    Returns a dictionary representation of all user
    permissions, sorted to allow an equivalency check.
    """

    allRolePerms = {}
    for role in auth.getRoleList():
	admin = auth.roleIsAdmin(role)
	mirror = auth.roleCanMirror(role)
	rolePerms = []
	for perm in auth.getPermsByRole(role):
	    perm['admin'] = admin
	    perm['mirror'] = mirror
	    rolePerms.append(sorted(perm.items()))
	allRolePerms[role] = rolePerms

    allUserPerms = {}
    for user in auth.userAuth.getUserList():
	userPerms = []
	for role in auth.getRoles(user):
	    userPerms.extend(allRolePerms[role])
	allUserPerms[user] = sorted(userPerms)
    return allUserPerms
	

def _renameRoles(auth, rolesToRename):
    """
    Takes a dict of {newname -> oldname} and renames roles from oldName 
    to newName. 
    """
    for newName, oldName in rolesToRename.items():
	# avoid conflicts by moving to a safe place first.
	auth.renameRole(oldName, newName + '.renaming')

    for newName, oldName in rolesToRename.items():
	auth.renameRole(newName + '.renaming', newName)

def _mergeRoles(auth, rolesToMerge):
    """
    Takes a dict of mainRole -> oldRoles and combines them.
    Assumes that newRole exists and should be included in the
    role list.
    """
    for roleName, mergingRoles in rolesToMerge.items():
	mergingRoles.append(roleName)
	mergingRoles = set(mergingRoles)
	if mergingRoles == set([roleName]):
	    # no change necessary.
	    continue
	members = []
	for mergingRoleName in mergingRoles:
	    members.extend(auth.getRoleMembers(mergingRoleName))
	    if mergingRoleName != roleName:
		auth.deleteRole(mergingRoleName)
	members = set(members)
	auth.updateRoleMembers(roleName, members)

	   



def main(argv):
    #if os.getuid():
#	print >> sys.stderr, "Error: %s must be run as root" % sys.argv[0]
#	sys.stderr.flush()
#	sys.exit(1)


    if '--force' not in argv:
	print "Executing this script will modify your repository access"
	print "controls to move all users to stardard owner, developer,"
	print "and user roles."
	print ""
	print "This should not affect the permissions of any users."
	print "Type 'yes' to continue"

	answer = sys.stdin.readline()[:-1]
	if answer.upper() != 'YES':
	    if answer.upper() not in ('', 'N', 'NO'):
		print >> sys.stderr, "you must type 'yes' to continue"
	    print >> sys.stderr, "aborting."
	    sys.exit(1)
    cfg = config.getConfig()
    updateRoles(cfg)

if __name__ == '__main__':
    main(sys.argv)

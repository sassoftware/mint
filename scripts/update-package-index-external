#!/usr/bin/python
#
# update-package-index-external
#
# Updates the package index for external projects on rBuilder
# using a net repository client.
#
# Copyright (c) 2005-2006 rPath, Inc.
#
# All rights reserved
#

from mint import config
from mint import pkgindex
from mint import projects
from mint.scriptlibrary import SingletonScript

from conary import sqlite3
from conary import versions
from conary import conaryclient
from conary import conarycfg
from conary import dbstore
from conary.repository import repository

import os
import os.path
import sys

class UpdatePackageIndexExternal(SingletonScript):

    db = None

    def action(self):
        cfg = config.MintConfig()
        cfg.read(config.RBUILDER_CONFIG)

        self.db = dbstore.connect(cfg.dbPath, driver = cfg.dbDriver)
        self.db.connect()
        self.db.loadSchema()
        cu = self.db.cursor()
        pkgIdx = pkgindex.PackageIndexTable(self.db)
        labelsTable = projects.LabelsTable(self.db, cfg)
        self.db.commit()

        cu = self.db.cursor()
        cu.execute("""SELECT projectId, hostname || '.' || domainname
                         FROM Projects
                         WHERE external=1 AND hidden=0 AND disabled=0""")

        labels = {}
        projectIds = {}
        netclients = {}

        for r in cu.fetchall():
            projectId, hostname = r

            self.log.info("Retrieving labels from %s...", hostname)
            l, repMap, userMap = labelsTable.getLabelsForProject(projectId,
                overrideAuth = True, newUser = 'anonymous', newPass = 'anonymous')

            hostname = repMap.keys()[0]
            labels[hostname] = versions.Label(l.keys()[0])
            projectIds[hostname] = projectId

            ccfg = conarycfg.ConaryConfiguration()
            conarycfgFile = os.path.join(cfg.dataPath, 'conaryrc')
            if os.path.exists(conarycfgFile):
                ccfg.read(conarycfgFile)
            ccfg.root = ccfg.dbPath = ':memory:'
            ccfg.repositoryMap = repMap
            repos = conaryclient.ConaryClient(ccfg).getRepos()
            netclients[hostname] = repos

        rows = []
        for host in netclients.keys():
            self.log.info("Retrieving trove list from %s...", host)
            try:
                troves = netclients[host].getAllTroveLeaves(host, {None: {None: None}})
            except repository.errors.OpenError, e:
                self.log.warning("unable to access %s", host)
                continue

            pkgs = [x for x in troves.keys() if ':' not in x]

            for pkg in pkgs:
                latestVer = sorted(troves[pkg].keys(), reverse = True)[0]
                row = (projectIds[host], pkg, latestVer.asString())
                rows.append(row)

            self.log.info("Retrieved %d trove%s from %s.", len(rows), ((len(rows) != 1) and 's' or ''), host)

        self.log.info("Updating database...")
        for row in rows:
            cu.execute("SELECT pkgId FROM PackageIndex WHERE projectId=? AND name=? AND version=?", *row)
            r = cu.fetchone()
            if r:
                pkgId = r[0]
                cu.execute("UPDATE PackageIndex SET projectId=?, name=?, version=? WHERE pkgId=?", row[0], row[1], row[2], pkgId)
            else:
                cu.execute("INSERT INTO PackageIndex VALUES (NULL, ?, ?, ?)", *row)

        self.db.commit()
        print "Update complete."
        return 0

    def cleanup(self):
        if self.db:
            self.db.close()


if __name__ == "__main__":
    upie = UpdatePackageIndexExternal()
    os._exit(upie.run())


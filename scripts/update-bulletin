#!/usr/bin/python
#
# Copyright (c) 2009 rPath, Inc.
#
# All rights reserved.
#

"""
Inserts/edits/removes notices automagically to match the
contents of bulletin.txt.
"""

import optparse
import os
import pickle
import sys
import time
from conary.lib import digestlib
from lxml import etree as ET
from lxml.builder import E
from mint import config
from mint import notices_store
from mint.lib.unixutils import AtomicFile


NS_CONTENT = 'http://purl.org/rss/1.0/modules/content/'


def main(args):
    op = optparse.OptionParser()
    op.add_option('-c', '--config', help="Path to the rBuilder config file",
            default=config.RBUILDER_CONFIG)

    options, args = op.parse_args(args)
    if args:
        op.error("Expected no arguments")

    cfg = config.MintConfig()
    cfg.read(options.config)

    # Load metadata about the last notice we inserted
    metaPath = os.path.join(cfg.dataPath, 'data/bulletin.meta')
    meta = {}
    if os.path.exists(metaPath):
        meta = pickle.load(open(metaPath))

    # Get a store via which to insert more notices
    store = notices_store.createStore(os.path.join(cfg.dataPath, 'notices'),
            cfg.authUser)
    baseUrl = 'https://%s/api/notices/contexts/' % cfg.secureHost

    try:
        bulletinStat = os.stat(cfg.bulletinPath)
    except OSError:
        bulletinStat = bulletin = digest = None
    else:
        bulletin = open(cfg.bulletinPath).read()
        digest = digestlib.sha1(bulletin).hexdigest()

    oldDigest = meta.get('digest', None)
    if oldDigest:
        # If the existing bulletin is identical, do nothing.
        if digest == oldDigest:
            print 'Bulletin is unchanged'
            return 0

        # Otherwise, delete the old one.
        keyId = meta.get('keyId', None)
        if keyId:
            store.globalStore.delete(keyId)
            print 'Existing bulletin at %s has been deleted' % (
                    meta.get('guid', '<none>'))
            if os.path.exists(metaPath):
                os.unlink(metaPath)

    # Now add the new bulletin.
    if bulletin:
        # Create the placeholder notice so we get a GUID
        notice = store.storeGlobal('default', '<item/>')
        guid = baseUrl + notice.id

        # Construct a RSS feed item
        item = E.item()
        item.append(E.title(u'rBuilder Maintenance'))
        item.append(E.pubDate(time.strftime('%a, %d %b %Y %H:%M:%S GMT',
            time.gmtime(bulletinStat.st_mtime))))
        item.append(E.guid(guid))
        item.append(E.description(bulletin.decode('utf8')))

        # Write the finished item out as a notice
        notice.content = ET.tostring(item, encoding='UTF-8')
        store.storeGlobal(None, notice)

        # Write metadata so we can delete this later
        meta = {'keyId': notice.id, 'digest': digest, 'guid': guid}
        metaFile = AtomicFile(metaPath)
        pickle.dump(meta, metaFile)
        metaFile.commit()

        print 'Bulletin posted as', guid

    return 0


if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))

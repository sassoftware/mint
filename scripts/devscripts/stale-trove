#!/usr/bin/python

import os
import sys
from conary import conaryclient
from conary.conaryclient import cmdline
from conary import versions
from conary.lib import util
from conary import trove
from conary.repository import changeset
import tempfile
import optparse

cc = conaryclient.ConaryClient()
nc = cc.getRepos()

cc.cfg.readFiles()

def setContext(cfg, argSet):
    context = cfg.context
    if os.access('CONARY', os.R_OK):
        conaryState = state.ConaryStateFromFile('CONARY')
        if conaryState.hasContext():
            context = conaryState.getContext()

    context = os.environ.get('CONARY_CONTEXT', context)
    context = argSet.pop('context', context)

    if context:
        cfg.setContext(context)

def captureOutput(func, *args, **kwargs):
    fd = os.open(os.devnull, os.W_OK)
    oldStdErr = os.dup(sys.stderr.fileno())
    oldStdOut = os.dup(sys.stdout.fileno())
    os.dup2(fd, sys.stdout.fileno())
    os.dup2(fd, sys.stderr.fileno())
    os.close(fd)
    try:
        return func(*args, **kwargs)
    finally:
        os.dup2(oldStdOut, sys.stdout.fileno())
        os.dup2(oldStdErr, sys.stderr.fileno())

def newerSource(troveSpec):
    n, v, f = cmdline.parseTroveSpec(troveSpec)

    NVF = nc.findTrove(None, (n, v, f), cc.cfg.flavor)[0]
    trv = nc.getTrove(NVF[0], NVF[1], NVF[2], withFiles = False)

    sNVF = nc.findTrove(None, (trv.getSourceName(),
                            str(trv.getVersion().getSourceVersion().branch()), None))[0]
    srcTrv = nc.getTrove(sNVF[0], sNVF[1], sNVF[2], withFiles = False)

    return srcTrv.version() > trv.version()

def staleGroup(troveSpec):
    if not troveSpec.startswith('group-'):
        return False

    n, v, f = cmdline.parseTroveSpec(troveSpec)

    NVF = nc.findTrove(None, (n, v, f), cc.cfg.flavor)[0]
    trv = nc.getTrove(NVF[0], NVF[1], NVF[2], withFiles = False)

    sn = trv.getSourceName().replace(':source', '')
    sv = trv.getVersion().getSourceVersion()

    srcTroveSpec = (str(sn) + '=' + str(sv))

    tmpDir = tempfile.mkdtemp()
    try:
        for fn in [x for x in os.listdir('.') if x in ('conaryrc', 'CONARY')]:
            util.copyfile(fn, os.path.join(tmpDir, fn))
        curDir = os.getcwd()
        os.chdir(tmpDir)

        cmd = 'cvc co %s' % srcTroveSpec
        if cc.cfg.context:
            cmd += ' --context %s' % cc.cfg.context
        captureOutput(util.execute, cmd)
        os.chdir(os.path.join(tmpDir, sn))

        cmd = 'cvc cook %s.recipe' % sn
        if cc.cfg.context:
            cmd += ' --context %s' % cc.cfg.context

        try:
            captureOutput(util.execute, cmd)
        except RuntimeError, e:
            if 'exited with exit code 1' in str(e):
                print >> sys.stderr, "%s could not be cooked" % srcTroveSpec
                sys.exit(-1)
        ccsfn = [x for x in os.listdir('.') if x.endswith('.ccs')][0]
        cs = changeset.ChangeSetFromFile(ccsfn)
        newTrv = trove.Trove([x for x in cs.iterNewTroveList()][0])
        return sorted([x for x in trv.iterTroveList(strongRefs = True,
                                                    weakRefs=True)]) != \
               sorted([x for x in newTrv.iterTroveList(strongRefs = True,
                                                       weakRefs=True)])
    finally:
        os.chdir(curDir)
        util.rmtree(tmpDir)

def stale(troveSpec):
    return newerSource(troveSpec) or staleGroup(troveSpec)

if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.add_option("-c", "--context", dest = "context",
                      action = "store",
                      help = "Set a conary context.")
    (options, args) = parser.parse_args()

    options = options.__dict__
    setContext(cc.cfg, options)

    if len(args) == 1:
        r = stale(args[0])
        print r
        sys.exit(int(r))
    else:
        print "Usage: %s <trovespec>" % os.path.basename(sys.argv[0])
        sys.exit(-1)

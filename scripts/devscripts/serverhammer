#!/usr/bin/python
#
# Copyright (c) 2006 rPath, Inc.
#
# All rights reserved
#

######
#
# Set these values as needed
#
RBO_SERVER = 'mint.rpath.local'
RBO_PORT = 80
CLIENT_THREADS = 10
######

import os, sys

mintPath = '/'.join(os.getcwd().split('/')[:-1])

conaryPath = os.getenv('CONARY_PATH')
if not conaryPath:
    raise AssertionError('Please set CONARY_PATH')

pythonPath = os.getenv('PYTHONPATH')
if pythonPath:
    missing = []
    if mintPath not in pythonPath:
        missing.append(mintPath)
    if conaryPath not in pythonPath:
        missing.append(conaryPath)
else:
    missing = [mintPath, conaryPath]

if missing:
    raise AssertionError('Please ensure PYTHONPATH contains %s' %
                         ' and '.join(missing))

from mint import client

import unittest
import webunit
from webunit import webunittest
import threading
import random
import time

mc = client.MintClient("http://mintauth:mintpass@%s:%s/xmlrpc-private" % \
                     (RBO_SERVER, RBO_PORT))

pgpKey = """
-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: GnuPG v1.4.2 (GNU/Linux)

mIsEQ8FWQQEEAM4uaFYLugV9kojaSZFe3IksfwIXQrTZnTQ3Ehn/vrWEVGKZJEbc
bjvroUDjBLFOTyv7hrcjLulKsgMk2VY/TzsVUk9BcG/r48MR8eM7KziTTtzJf401
wcEJ0NOsD+Yk1KTHgBdVkUHscncct70HLx6/+feyTUXnqobk2LQh55alAAYptA1y
Qk8gVGVzdCBVc2VyiLYEEwECACAFAkPBVkECGwMGCwkIBwMCBBUCCAMEFgIDAQIe
AQIXgAAKCRDFEQh4/eApH94tA/90ynC5nm1mOr2wJf6UqUULZ413OvnojPzGwLcn
soDUq191S3ZhAds/Sn6/MN7hWmWBJGGCVPGLhogV1B7aFxTacV/+LzV9tMbZlYXx
U2WLvJT0oMK5/mLkX6fodxVLTE9F3SCtee7hzgQbWRsUDMH2M1iUCjp7lEzE8NUU
Mrs7JA==
=AjQ+
-----END PGP PUBLIC KEY BLOCK-----
"""

class Callback(object):
    def __init__(self):
        self.lock = threading.RLock()

    def write(self, message):
        self.lock.acquire()
        print message
        self.lock.release()

class WebStateMachine(webunittest.WebTestCase):
    def __init__(self, methodName, callback):
        webunittest.WebTestCase.__init__(self, methodName)

        self.callback = callback

        self.state = STATE_ANON_INITIAL
        self.userName = None
        self.loggedIn = False
        self.projectName = None
        self.groupId = None

    def _randomString(self):
        return hex(random.randint(0, 2**64))[1:]

    def setUp(self):
        webunittest.WebTestCase.setUp(self)

        self.setAcceptCookies(True)
        self.server, self.port = RBO_SERVER, RBO_PORT

        webunittest.HTTPResponse._TestCase__testMethodName = \
                                          self._TestCase__testMethodName
        page = self.fetch('')

    def tearDown(self):
        self.clearCookies()
        webunittest.WebTestCase.tearDown(self)

    def testRun(self):
        pass

    def clock(self):
        # if this function returns True, there's more work to do. if it returns
        # False, the state is final and no more web calls will be made.
        if self.state in stateActions:
            startTime = time.time()
            self.state = random.choice(stateActions[self.state])(self)
            stopTime = time.time()

            if self.state not in (STATE_ANON_INITIAL, STATE_USER_INITIAL):
                self.callback.write("%s:%s:%s:%s" % \
                                    (time.time(),
                                     actionNames[self.state],
                                     self.loggedIn and self.userName or \
                                     'anonymous',
                                     (stopTime - startTime)))

            # give browser a small chance to just quit
            #if not random.randint(0, 1000):
            #    return False

            return True

        return False

    def initial(self):
        if self.loggedIn:
            return STATE_USER_INITIAL
        return STATE_ANON_INITIAL

    def register(self):
        self.userName = self._randomString()[:16]

        page = self.fetch('/register')
        page.postForm(1, self.post, {'username':  self.userName,
                                     'password':  'foopass',
                                     'password2': 'foopass',
                                     'email':     'foo@localhost',
                                     'email2':     'foo@localhost',
                                     'tos':       'True',
                                     'privacy':   'True'})

        return STATE_REGISTERED

    def confirm(self):
        conf = mc.getConfirmation(self.userName)
        self.fetch('/confirm?id=%s' % conf)

        return STATE_CONFIRMED

    def browse(self):
        self.fetch('/projects?sortOrder=%d' % random.randint(0,9))
        return STATE_BROWSE

    def search(self):
        self.fetch('/search?type=%s&search=%s' % \
                   (random.choice(('Projects', 'Packages')),
                   self._randomString()))
        return STATE_SEARCH

    def login(self):
        page = self.fetch('')
        page.postForm(0, self.post,{'username': self.userName,
                                    'password': 'foopass'})

        self.loggedIn = True
        return STATE_LOGGED_IN

    def logout(self):
        self.fetch('/logout')
        self.loggedIn = False
        return STATE_LOGGED_OUT

    def createProject(self):
        self.projectName = self._randomString()

        page = self.fetch('/newProject')
        page.postForm(1, self.post, {'hostname': self.projectName,
                                     'title': self.projectName})

        return STATE_CREATED_PROJECT

    def commit(self):
        # FIXME: do a bona fide commit
        return STATE_COMMITTED

    def member(self):
        page = self.fetch('/project/%s/members' % self.projectName.lower())

        page.postForm(1, self.post, {'username': self.userName,
                                     'level': '0'})
        return STATE_MEMBER

    def orphan(self):
        userId = mc.getUserIdByName(self.userName)

        self.fetch('/project/%s/delMember?id=%d' % (self.projectName.lower(),
                                                    userId))
        return STATE_ORPHANED

    def newGroup(self):
        page = self.fetch('/project/%s/createGroup' % self.projectName.lower(),
                          postdata = { 'groupName' : self._randomString(),
                                       'version'   : '1.0.0',
                                       'initialTrove' : "group-base /conary.rpath.com@rpl:devel//1/0.99.3-0.7-8 1#x86:cmov:i486:i586:i686:~!mmx:~!sse2|5#use:X:~!alternatives:~!bootstrap:~!builddocs:~buildtests:desktop:dietlibc:emacs:gcj:~glibc.tls:gnome:~!grub.static:gtk:ipv6:kde:~!kernel.debug:~!kernel.debugdata:~!kernel.numa:krb:ldap:nptl:~!openssh.smartcard:~!openssh.static_libcrypto:pam:pcre:perl:~!pie:~!postfix.mysql:python:qt:readline:sasl:~!selinux:~sqlite.threadsafe:ssl:tcl:tcpwrappers:tk:~!xorg-x11.xprint"})

        self.groupId = int(page.body.split('id=')[1].split('"')[0])

        return STATE_NEW_GROUP

    def cookGroup(self):
        page = self.fetch('/project/%s/pickArch?id=%d' % \
                          (self.projectName.lower(), self.groupId))

        page.postForm(1, self.post, { \
            'arch' : (random.randint(0, 1) and "1#x86" or "1#x86_64"),
            'id' : str(self.groupId)})

        return STATE_COOK_GROUP

    def uploadKey(self):
        if random.randint(0, 1):
            page = self.fetch('/repos/%s/pgpNewKeyForm' % \
                              self.projectName.lower())
            page.postForm(1, self.post, {'keyData' : pgpKey})

        else:
            page = self.fetch('/uploadKey')
            page.postForm(1, self.post,
                          {'projects': {self.projectName.lower(): 'selected'},
                           'keydata': pgpKey})

        return STATE_LOADED_KEY



(STATE_ANON_INITIAL, \
 STATE_USER_INITIAL, \
 STATE_REGISTERED, \
 STATE_CONFIRMED, \
 STATE_LOGGED_IN, \
 STATE_LOGGED_OUT, \
 STATE_CREATED_PROJECT, \
 STATE_MEMBER, \
 STATE_ORPHANED, \
 STATE_COMMITTED, \
 STATE_LOADED_KEY, \
 STATE_NEW_GROUP, \
 STATE_COOK_GROUP, \
 STATE_BROWSE, \
 STATE_SEARCH) = range(15)


actionNames = {
    STATE_ANON_INITIAL:        '(anonymous initial state)',
    STATE_USER_INITIAL:        '(user initial state)',
    STATE_REGISTERED:          'registered',
    STATE_CONFIRMED:           'confirmed',
    STATE_BROWSE:              'browse',
    STATE_SEARCH:              'search',
    STATE_LOGGED_IN:           'logged in',
    STATE_CREATED_PROJECT:     'created project',
    STATE_MEMBER:              'added member',
    STATE_ORPHANED:            'orphaned',
    STATE_COMMITTED:           'commited',
    STATE_NEW_GROUP:           'new group',
    STATE_COOK_GROUP:          'cooked group',
    STATE_LOADED_KEY:          'uploaded pgp key',
    STATE_LOGGED_OUT:          'logged out'
    }


stateActions = {
    STATE_ANON_INITIAL:    (WebStateMachine.browse,
                            WebStateMachine.search,
                            WebStateMachine.register),

    STATE_USER_INITIAL:    (WebStateMachine.logout,
                            WebStateMachine.browse,
                            WebStateMachine.search,
                            WebStateMachine.createProject),

    STATE_REGISTERED:      (WebStateMachine.confirm,),

    STATE_CONFIRMED:       (WebStateMachine.initial,
                            WebStateMachine.login),

    STATE_BROWSE:          (WebStateMachine.initial,),

    STATE_SEARCH:          (WebStateMachine.initial,),

    STATE_LOGGED_IN:       (WebStateMachine.initial,),

    STATE_LOGGED_OUT:      (WebStateMachine.initial,
                            WebStateMachine.login),

    STATE_CREATED_PROJECT: (WebStateMachine.uploadKey,
                            WebStateMachine.commit,
                            WebStateMachine.initial,
                            WebStateMachine.member,
                            WebStateMachine.orphan,
                            WebStateMachine.newGroup),

    STATE_MEMBER:          (WebStateMachine.initial,
                            WebStateMachine.commit,
                            WebStateMachine.uploadKey,
                            WebStateMachine.initial,
                            WebStateMachine.orphan,
                            WebStateMachine.newGroup),

    STATE_ORPHANED:        (WebStateMachine.initial,),

    STATE_LOADED_KEY:      (WebStateMachine.commit,
                            WebStateMachine.initial,
                            WebStateMachine.member,
                            WebStateMachine.uploadKey,
                            WebStateMachine.orphan,
                            WebStateMachine.newGroup),

    STATE_COMMITTED:       (WebStateMachine.commit,
                            WebStateMachine.initial,
                            WebStateMachine.member,
                            WebStateMachine.uploadKey,
                            WebStateMachine.orphan,
                            WebStateMachine.newGroup),

    STATE_NEW_GROUP:       (WebStateMachine.cookGroup,),

    STATE_COOK_GROUP:      (WebStateMachine.commit,
                            WebStateMachine.initial,
                            WebStateMachine.member,
                            WebStateMachine.uploadKey,
                            WebStateMachine.orphan,
                            WebStateMachine.newGroup),
    }


class HammerThread(threading.Thread):
    def __init__(self, callback):
        threading.Thread.__init__(self)
        self.callback = callback

    def run(self):
        t = WebStateMachine('testRun', self.callback)
        t.setUp()

        while t.clock():
            time.sleep(random.uniform(.1, 1))

        t.tearDown()


if __name__ == '__main__':
    suffixes = ('rpath.org', 'rpath.com', 'rpath.net')

    if True in [RBO_SERVER.lower().endswith(x) for x in suffixes]:
        raise AssertionError('This script makes irreversible changes to '
                             'rBuilder servers. Please set RBO_SERVER (at the '
                             'top of this script) to something other than a '
                             'permanent installation.')

    c = Callback()
    hThreads = []

    for i in range(CLIENT_THREADS):
        h = HammerThread(c)
        h.start()
        hThreads.append(h)
        time.sleep(random.uniform(1, 3))

    for h in hThreads:
        h.join()

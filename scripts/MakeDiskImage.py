import os, sys, errno, tempfile, time
from conary.lib import util
from conary import conarycfg, conaryclient, versions, updatecmd
from conary.repository import errors
from conary.conaryclient.cmdline import parseTroveSpec
from urlparse import urlparse
import hotshot

#Different cylinder sizes.  I don't know which is better, but I've seen
#both: 8225280 or 516096
cylindersize = 516096
sectors = 63
heads = 16

partoffset0 = 512

datadir = os.path.join(os.path.dirname(__file__), 'DiskImageData')

def debugme(type, value, tb):
    from conary.lib import epdb
    epdb.post_mortem(tb,type,value)


class Journal:
    def lchown(self, root, target, user, group):
        # get rid of the root
        target = target[len(root):]
        dirname = os.path.dirname(target)
        filename = os.path.basename(target)
        f = open(os.sep.join((root, dirname, '.UIDGID')), 'a')
        # XXX e2fsimage does not handle group lookups yet
        f.write('%s %s\n' %(filename, user))
        f.close()

    def mknod(self, root, target, devtype, major, minor, mode,
              uid, gid):
        # get rid of the root
        target = target[len(root):]
        dirname = os.path.dirname(target)
        filename = os.path.basename(target)
        f = open(os.sep.join((root, dirname, '.DEVICES')), 'a')
        # XXX e2fsimage does not handle symbolic users/groups for .DEVICES
        f.write('%s %s %d %d 0%o\n' %(filename, devtype, major, minor, mode))
        f.close()

def timeMe(func):
    def wrapper(self, *args, **kwargs):
        clock = time.clock()
        actual = time.time()
        returner = func(self, *args, **kwargs)
        print "%s: %.5f %.5f" % (func.__name__, time.clock() - clock, time.time() - actual)
        return returner
    return wrapper

def outputfilesize(func):
    def wrapper(self, *args, **kwargs):
        returner = func(self, *args, **kwargs)
        st = os.stat(self.outfile)
        print "size of %s after %s: %d bytes" % (self.outfile, func.__name__, st.st_size)
        return returner
    return wrapper

class BootableDiskImage:
    fakeroot = None

    def __init__(self, file, size, group, installLabel, repoMap=None, arch='x86'):
        sys.excepthook = debugme
        self.outfile = file
        self.freespace = size
        self.basetrove, self.baseversion, self.baseflavor = parseTroveSpec(group)
        self.InstallLabel = installLabel.split()
        if not repoMap:
            key = self.InstallLabel[0]
            host, label = key.split('@')
            self.repoMap = {key: 'http://' + host + '/conary/'}
            #self.host = host
        else:
            self.repoMap = repoMap
            #self.host = urlparse(repoMap[
        self.arch = arch

    @outputfilesize
    @timeMe
    def prepareDiskImage(self):
        #erase the file if it exists
        try:
            os.unlink(self.outfile)
        except OSError, e:
            if e.errno != errno.ENOENT:
                raise e
        #create the disk file
        ofile = open(self.outfile, 'wb', 0644)
        ofile.seek(self.imagesize-1)
        ofile.write('\x00')
        ofile.close()

        #Do the partition table
        cylinders = self.imagesize / cylindersize
        cmd = '/sbin/sfdisk -C %d -S %d -H %d %s > /dev/null' % (cylinders, sectors, heads, self.outfile)
        input = "0 %d L *\n" % (cylinders)
        sfdisk = util.popen(cmd, 'w')
        sfdisk.write(input)
        retval = sfdisk.close()
        #Don't worry about formatting or labeling

    def _writefstab(self):
        util.copyfile(os.path.join(datadir, 'fstab'), os.path.join(self.fakeroot, 'etc'))

    def _setupGrub(self):
	util.copytree(os.path.join(self.fakeroot, 'usr', 'share', 'grub', '*', '*'), os.path.join(self.fakeroot, 'boot', 'grub'))
	#Create a stub grub.conf
	name = open(os.path.join(self.fakeroot, 'etc', 'issue'), 'r').readlines()[0].strip()
	fd = open(os.path.join(self.fakeroot, 'boot', 'grub', 'grub.conf'), 'w')
	fd.write("""
#grub.conf generated by rBuilder
#
# Note that you do not have to rerun grub after making changes to this file
#boot=/dev/hda
default=0
timeout=10
title %(name)s (%(kversion)s)
    root (hd0,0)
    kernel /boot/vmlinuz-%(kversion)s ro root=LABEL=/ quiet
    initrd /boot/initrd-%(kversion)s.img

""" % {'name': name, 'kversion': 'somesillyversion'})
	os.chmod(os.path.join(self.fakeroot, 'boot/grub/grub.conf'), 0600)
	fd.close()
	#create the appropriate links
	os.symlink('grub.conf', os.path.join(self.fakeroot, 'boot', 'grub', 'menu.lst'))
	os.symlink('../boot/grub/grub.conf', os.path.join(self.fakeroot, 'etc', 'grub.conf'))

    @timeMe
    def createTemporaryRoot(self, basedir = os.getcwd()):
        #Create a temporary directory
        self.fakeroot = tempfile.mkdtemp('', 'mint-MDI-', basedir)
        #Create some structure
        cwd = os.getcwd()
        os.chdir(self.fakeroot)
        util.mkdirChain( 'etc', 'boot/grub', 'tmp', 'sys' )
        os.chdir(cwd)

    @timeMe
    def setupConaryClient(self):
        #Create a ConaryClient
        cfg = conarycfg.ConaryConfiguration(readConfigFiles=False)
        cfg.repositoryMap = self.repoMap
        cfg.flavor = None
        cfg.root = self.fakeroot
        cfg.installLabelPath = None
        #TODO Add the user if anonymous access is not available
        #servername = urlparse(self.repoMap[1])[1]
        #if ':' in servername:
        #    servername = servername.split(':')[0]
        #cfg.addServerGlob(servername, 'anonymous', 'anonymous')

        self.cclient = conaryclient.ConaryClient(cfg)

    @timeMe
    def updateGroupChangeSet(self):
        try:
            itemList = [(self.basetrove, (None, None), (self.baseversion, self.baseflavor), True)]
            sys.stderr.flush()
            uJob, suggMap = self.cclient.updateChangeSet(itemList, resolveDeps = False)
        except errors.TroveNotFound:
            raise
        return uJob

    @timeMe
    def applyGroupUpdate(self, uJob):
        #Capture devices, taghandlers and ownership changes
        journal = Journal()
        #Install the group
        self.cclient.applyUpdate(uJob, journal=journal, tagScript=os.path.join(self.fakeroot, 'tmp', 'tag-scripts'))

    @timeMe
    def populateTemporaryRoot(self):
        uJob = self.updateGroupChangeSet()
        self.applyGroupUpdate(uJob)

    @timeMe
    def updateKernelChangeSet(self):
        #Install the Kernel
        try:
            kernel, version, flavor = parseTroveSpec('kernel[!kernel.smp is: %s]' % self.arch)
            itemList = [(kernel, (None, None), (version, flavor), True)]
            uJob, suggMap = self.cclient.updateChangeSet(itemList, sync=True,
                                resolveDeps=False)
        except errors.TroveNotFound:
            raise
        return uJob

    @timeMe
    def applyKernelUpdate(self, uJob):
        journal = Journal()
        self.cclient.applyUpdate(uJob, journal=journal, tagScript=os.path.join(self.fakeroot, 'tmp', 'kernel-tag-scripts'))

    @timeMe
    def installKernel(self):
        uJob = self.updateKernelChangeSet()
        self.applyKernelUpdate(uJob)

    @timeMe
    def fileSystemOddsNEnds(self):
        #write the fstab
        self._writefstab()
	#create a swap file
	swap = open(os.path.join(self.fakeroot, 'var', 'swap'), 'w')
	swap.seek(128*1024*1024 - 1)
	swap.write('\x00')
	swap.close()
	#Initialize the swap file
	cmd = '/sbin/mkswap %s' % os.path.join(self.fakeroot, 'var', 'swap')
	util.execute(cmd)
	#copy the files needed by grub and set up the links
	self._setupGrub()
        #Create the init script
        util.copyfile(os.path.join(datadir, 'init.sh'), os.path.join(self.fakeroot, 'tmp'))
        os.chmod(os.path.join(self.fakeroot, 'tmp', 'init.sh'), 0755)
        util.copyfile(os.path.join(datadir, 'pre-tag-scripts'), os.path.join(self.fakeroot, 'tmp'))
        util.copyfile(os.path.join(datadir, 'post-tag-scripts'), os.path.join(self.fakeroot, 'tmp'))
        util.copyfile(os.path.join(datadir, 'post-kernel-tag-scripts'), os.path.join(self.fakeroot, 'tmp'))

    @timeMe
    def MakeE3FsImage(self, file):
        cmd = '/usr/bin/e2fsimage -f %s -d %s -s %d' % (file,
                self.fakeroot, (self.imagesize - partoffset0)/1024)
        util.execute(cmd)
        cmd = '/sbin/e2label %s /' % file
        util.execute(cmd)
        cmd = '/sbin/tune2fs -i 0 -c 0 -j %s' % file
        util.execute(cmd)

    @outputfilesize
    @timeMe
    def WriteBack(self, file):
        #Now write this FS image back to the original image
        fd = open(file, 'rb')
        fdo = open(self.outfile, 'r+b')
        fdo.seek(partoffset0)
        util.copyfileobj(fd, fdo, bufSize=524288)
        fd.close()
        fdo.close()
 
    @timeMe
    def createFileSystem(self, basedir = os.getcwd()):
        fd, file = tempfile.mkstemp('', 'mint-MDI-cFS-', basedir)
        os.close(fd)
        del fd
        try:
            #How much space do we need?
            fd = os.popen('/usr/bin/du -B1 --max-depth=0 %s' % self.fakeroot, 'r')
            size = int(fd.read().strip().split()[0])
            size += self.freespace + partoffset0
            padding = cylindersize - (size % cylindersize)
            if cylindersize == padding:
                padding = 0
            self.imagesize = size + padding
            self.MakeE3FsImage(file)
            self.prepareDiskImage()
            self.WriteBack(file)
        finally:
            pass
            #os.unlink(file)

    @timeMe
    def runTagScripts(self):
        cmd = './uml-vmlinux root=/dev/ubda1 init=/tmp/init.sh mem=128M ubd0=%s > uml-vmlinux.log' % self.outfile
	util.execute(cmd)

    @timeMe
    def makeBootable(self):
        #install boot manager
        cmd = '%s --device-map=/dev/null --batch > grub-install.log' % os.path.join(self.fakeroot, 'sbin', 'grub')
	input = """
device  (hd0)   %s
root    (hd0,0)
setup   (hd0)
quit
""" % self.outfile
        uml = util.popen(cmd, 'w')
        uml.write(input)
        retval = uml.close()

    @timeMe
    def makeBootableDiskImage(self, basedir = os.getcwd()):
        self.createTemporaryRoot(basedir)
        self.setupConaryClient()
        self.populateTemporaryRoot()
        self.installKernel()
        self.fileSystemOddsNEnds()
        self.createFileSystem()
	self.runTagScripts()
        self.makeBootable()

    def __del__(self):
        #Cleanup: remove the fakeroot
        if self.fakeroot:
            pass
            #util.rmtree(self.fakeroot)

def main():
    #di = BootableDiskImage('foo.img', 250000000, 
        #'group-dist=/conary.rpath.com@rpl:devel//1/0.99.3-0.2-5[X,~!alternatives,~!bootstrap,~!builddocs,~buildtests,desktop,dietlibc,emacs,gcj,~glibc.tls,gnome,~!grub.static,gtk,ipv6,kde,~!kernel.debug,~!kernel.debugdata,~!kernel.numa,krb,ldap,nptl,~!openssh.smartcard,~!openssh.static_libcrypto,pam,pcre,perl,~!pie,~!postfix.mysql,python,qt,readline,sasl,~!selinux,~sqlite.threadsafe,ssl,tcl,tcpwrappers,tk,~!xorg-x11.xprint is: x86(cmov,i486,i586,i686,~!mmx,~!sse2)]',
        #'conary.rpath.com@rpl:1 contrib.rpath.org@rpl:devel', repoMap = {'conary.rpath.com': 'http://conary-commits.rpath.com/conary/'})
    #di = BootableDiskImage('foo.img', 250*1024*1024, 'group-dist=foobar.org.rpath@rpl:devel', 'foobar.org.rpath@rpl:devel conary.rpath.com@rpl:1 contrib.rpath.org@rpl:devel')
    di = BootableDiskImage('foo.img', 250*1024*1024,
        'group-system=/systemimages.org.rpath@rpl:devel/0.0.1-1-1[X,~!alternatives,~!bootstrap,~!builddocs,~buildtests,desktop,dietlibc,emacs,gcj,~glibc.tls,gnome,~!grub.static,gtk,ipv6,kde,~!kernel.debug,~!kernel.debugdata,~!kernel.numa,krb,ldap,nptl,~!openssh.smartcard,~!openssh.static_libcrypto,pam,pcre,perl,~!pie,~!postfix.mysql,python,qt,readline,sasl,~!selinux,~sqlite.threadsafe,ssl,tcl,tcpwrappers,tk,~!xorg-x11.xprint   is: x86(cmov,i486,i586,i686,~!mmx,~!sse2)]',
        'rbuilder.org.rpath@rpl:devel conary.rpath.com@rpl:1 contrib.rpath.org@rpl:devel')
    di.makeBootableDiskImage()

main()

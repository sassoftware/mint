#!/usr/bin/python
#
# Copyright (c) 2005 rPath, Inc.
#
# All rights reserved
#
from mint import config
from mint.scriptlibrary import SingletonScript
from conary import dbstore

import os
import os.path
import sys

class UpdatePackageIndex(SingletonScript):

    cfgPath = "/srv/mint/mint.conf"
    db = None

    def handle_args(self):
        if len(sys.argv) > 1:
            self.cfgPath = sys.argv[1]
        return True

    def action(self):
        cfg = config.MintConfig()
        cfg.read(self.cfgPath)

        self.db = dbstore.connect(cfg.dbPath, driver = cfg.dbDriver)
        self.db.loadSchema()
        cu = self.db.cursor()

        try:
            cu.execute("SELECT MAX(timestamp) FROM Commits")
            newMark = cu.fetchone()[0]

            # Clear out Package index if the timestamp in PackageIndexMark == 0
            cu.execute("""DELETE FROM PackageIndex WHERE
                              (SELECT mark FROM PackageIndexMark) = 0""")

            # Get a list of the latest version of each package, excluding 
            # hidden and disabled projects. Comparing version strings isn't 
            # technically reliable, so we must use the latest timestamp to 
            # verify grab only the packages that have been updated since 
            # the last time this script was run.
            cu.execute("""SELECT Projects.projectId, troveName, max(timestamp)
                              FROM Commits
                              LEFT JOIN Projects
                                  ON Commits.projectId=Projects.projectId
                              WHERE troveName NOT LIKE '%:%'
                              AND hidden=0 AND disabled=0
                              AND timestamp >=
                                  (SELECT mark FROM PackageIndexMark)
                              GROUP BY Projects.projectId, troveName""")

            for projectId, troveName, maxTime in cu.fetchall():
                cu.execute("""SELECT version FROM Commits
                                  WHERE projectId=? AND troveName=?
                                  AND timestamp=?""",
                           projectId, troveName, maxTime)

                # at least one result will always exist. 
                # there should be only one.
                version = cu.fetchone()[0]

                cu.execute("""SELECT pkgId FROM PackageIndex
                                  WHERE projectId=? AND name=?""",
                           projectId, troveName)
                res = cu.fetchone()
                if not res:
                    cu.execute("""INSERT INTO PackageIndex 
                                      (projectId, name, version)
                                      VALUES (?, ?, ?)""",
                               projectId, troveName, version)
                    pass
                else:
                    pkgId = res[0]
                    cu.execute("""UPDATE PackageIndex SET
                                          projectId=?, name=?, version=?
                                          WHERE pkgId=?""",
                               projectId, troveName, version, pkgId)
            cu.execute("UPDATE PackageIndexMark SET mark=?", newMark)

        except:
            self.db.rollback()
            exitcode = 1
            raise
        else:
            exitcode = 0
            self.db.commit()
        return exitcode

    def cleanup(self):
        if self.db:
            self.db.close()

if __name__ == "__main__":
    upi = UpdatePackageIndex()
    os._exit(upi.run())


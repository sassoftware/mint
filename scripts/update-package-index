#!/usr/bin/python
#
# Copyright (c) 2005 rPath, Inc.
#
# All rights reserved
#
import conary
import sqlite3
import versions

from mint import config
from mint import pkgindex
from mint import projects
from repository import netclient
from repository import repository

cfgPath = "/srv/mint/mint.conf"

cfg = config.MintConfig()
cfg.read(cfgPath)

db = sqlite3.connect(cfg.dbPath, timeout = 30000)
cu = db.cursor()
cu.execute("SELECT tbl_name FROM sqlite_master WHERE type = 'table'")
db.tables = [ x[0] for x in cu.fetchall() ]

pkgIdx = pkgindex.PackageIndexTable(db)
labelsTable = projects.LabelsTable(db)

cu = db.cursor()
cu.execute("SELECT projectId, hostname || '.' || domainname FROM Projects WHERE hidden=0 AND disabled=0")

labels = {}
projectIds = {}
netclients = {}
for r in cu.fetchall():
    projectId, hostname = r

    l, repMap = labelsTable.getLabelsForProject(projectId, useSSL = cfg.SSL)
    
    hostname = repMap.keys()[0]
    labels[hostname] = versions.Label(l.keys()[0])
    projectIds[hostname] = projectId

    repos = netclient.NetworkRepositoryClient(repMap)
    netclients[hostname] = repos

rows = []
for host in netclients.keys():
    try:
        troves = netclients[host].getAllTroveLeaves(host, {None: {None: None}})

    except repository.OpenError, e:
        print "warning: unable to access %s" % host
        continue
        
    pkgs = [x for x in troves.keys() if ':' not in x]
    
    for pkg in pkgs:
        latestVer = sorted(troves[pkg].keys(), reverse = True)[0]
        row = (projectIds[host], pkg, latestVer.asString())
        rows.append(row)

cu.execute("BEGIN")
try:
    cu.execute("DELETE FROM PackageIndex")
    for row in rows:
        cu.execute("INSERT INTO PackageIndex VALUES (NULL, ?, ?, ?)", *row)
except:
    db.rollback()
    raise
else:
    db.commit()

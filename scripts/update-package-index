#!/usr/bin/python
#
# Copyright (c) 2005 rPath, Inc.
#
# All rights reserved
#
from mint import config
from mint.scriptlibrary import SingletonScript
from conary import dbstore
from conary import versions

import os
import os.path
import sys

class UpdatePackageIndex(SingletonScript):

    cfgPath = "/srv/mint/mint.conf"
    db = None

    def handle_args(self):
        if len(sys.argv) > 1:
            self.cfgPath = sys.argv[1]
        return True

    def action(self):
        cfg = config.MintConfig()
        cfg.read(self.cfgPath)

        self.db = dbstore.connect(cfg.dbPath, driver = cfg.dbDriver)
        self.db.loadSchema()
        cu = self.db.cursor()

        try:
            cu.execute("SELECT MAX(timestamp) FROM Commits")
            newMark = cu.fetchone()[0]

            # Clear out Package index if the timestamp in PackageIndexMark == 0
            cu.execute("""DELETE FROM PackageIndex WHERE
                              (SELECT mark FROM PackageIndexMark) = 0""")

            cu.execute("""SELECT Projects.projectId, troveName, version,
                                 timestamp
                              FROM Commits
                              LEFT JOIN Projects
                                  ON Commits.projectId=Projects.projectId
                              WHERE troveName NOT LIKE '%:%'
                              AND hidden=0 AND disabled=0
                              AND timestamp >=
                                  (SELECT mark FROM PackageIndexMark)""")

            packageDict = {}
            labelMap = {}
            for projectId, troveName, verStr, timeStamp in cu.fetchall():
                troveEntry = packageDict.setdefault(troveName, {})
                version = versions.VersionFromString(verStr)
                label = str(version.branch().label())
                versionList = troveEntry.setdefault(label, [])

                version.resetTimeStamps(timeStamp)
                versionList.append(version)
                labelMap[label] = projectId

            packageIndex = []
            for troveName in packageDict:
                for label in packageDict[troveName]:
                    packageIndex.append((labelMap[label], troveName,
                                         max(packageDict[troveName][label])))

            for projectId, troveName, version in packageIndex:
                cu.execute("""SELECT pkgId, version FROM PackageIndex
                                  WHERE projectId=? AND name=?""",
                           projectId, troveName)

                res = [x[0] for x in cu.fetchall() if \
                       versions.VersionFromString(x[1]).branch().label() == \
                       version.branch().label()]

                if not res:
                    cu.execute("""INSERT INTO PackageIndex
                                      (projectId, name, version)
                                      VALUES (?, ?, ?)""",
                               projectId, troveName, str(version))
                    pass
                else:
                    pkgId = res[0]
                    cu.execute("""UPDATE PackageIndex SET
                                          projectId=?, name=?, version=?
                                          WHERE pkgId=?""",
                               projectId, troveName, str(version), pkgId)

            cu.execute("UPDATE PackageIndexMark SET mark=?", newMark)
        except:
            self.db.rollback()
            exitcode = 1
            raise
        else:
            exitcode = 0
            self.db.commit()
        return exitcode

    def cleanup(self):
        if self.db:
            self.db.close()

if __name__ == "__main__":
    upi = UpdatePackageIndex()
    os._exit(upi.run())


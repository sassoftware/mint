#!/usr/bin/env python2.4
# -*- python -*-
#
# Copyright (c) 2004-2005 rPath, Inc.
# All rights reserved
#

import sys
import os

import conary
from conary.lib import util
sys.excepthook = util.genExcepthook()

isoblocksize = 2048
maxisosize = 650 * 1024 * 1024
commonfiles = ('README', 'LICENSE')
basicminimal = ('group-core', 'group-base')

def usage():
    print 'usage: %s /path/to/distro' %sys.argv[0]
    sys.exit(1)

def join(*args):
    return os.sep.join(args)

def lndir(src, dest, excludes=None):
    for dirpath, dirnames, filenames in os.walk(src):
        curdir = dirpath[len(src) + 1:]
        if curdir in excludes:
            continue
        for d in dirnames:
            os.mkdir(join(dest, curdir, d))
        for f in filenames:
            if curdir:
                curfile = join(curdir, f)
            else:
                curfile = f
            if curfile in excludes:
                continue
            os.link(join(dirpath, f), join(dest, curfile))

def spaceused(path):
    if not os.path.isdir(path):
        sb = os.stat(path)
        return sb.st_size + (isoblocksize - sb.st_size % isoblocksize)

    total = 0
    for dirpath, dirnames, filenames in os.walk(path):
        for filename in filenames:
            filepath = join(dirpath, filename)
            sb = os.stat(filepath)
            # round up to an ISO9660 block
            total += sb.st_size + (isoblocksize - sb.st_size % isoblocksize)

    return total

def preparedir(unified, path, csdir):
    if os.path.isdir(path):
        print >> sys.stderr, 'removing stale', path
        util.rmtree(path)

    print >> sys.stderr, 'creating', path
    os.mkdir(path)
    base = path
    for d in csdir.split(os.sep):
        os.mkdir(join(base, d))
        base = join(base, d)
    for f in commonfiles:
        src = join(unified, f)
        if os.access(src, os.R_OK):
            os.link(src, join(path, f))

def writediscinfo(path, discnum, discinfo):
    newinfo = discinfo[:]
    newinfo[3] = str(discnum)
    f = open(join(path, '.discinfo'), 'w')
    f.write('\n'.join(newinfo))
    f.write('\n')
    f.close()

def reorderChangesets(f, csPath, initialSize):
    reservedTroves = []
    sizedList = []
    infoTroves = []
    for line in f:
        csFile = line.split()[0]
        trvName = line.split()[1]
        if trvName in basicminimal:
            reservedTroves.append(line)
        spaceUsed = spaceused(join(csPath, csFile))
        if trvName.startswith('info-'):
            infoTroves.append((spaceUsed, line))
        else:
            sizedList.append((spaceUsed, line))
    sizedList = [x for x in reversed(sorted(sizedList))]

    reservedList = []
    if reservedTroves:
        import conary.trove
        import conary.repository.changeset
        trvNames = set()
        for trvLine in reservedTroves:
            trvNames.add(trvLine.split()[1])
            cs = conary.repository.changeset.ChangeSetFromFile( \
                join(csPath, trvLine.split()[0]))
            trv = conary.trove.Trove([x for x in cs.iterNewTroveList()][0])
            for includedTrv in [x[0].split(':')[0] for x in \
                                trv.iterTroveList(strongRefs = True,
                                                  weakRefs = True)]:
                trvNames.add(includedTrv)

        for size, line in sizedList[:]:
            if line.split()[1] in trvNames:
                reservedList.append((size, line))
                sizedList.remove((size, line))

    sizedList = infoTroves + reservedList + sizedList

    reOrdList = [[[], maxisosize - initialSize]]

    for size, line in sizedList:
        match = False
        for i, (changesets, limit) in enumerate(reOrdList):
            if size <= limit:
                reOrdList[i][0].append(line)
                reOrdList[i][1] -= size
                match = True
                break
        if not match:
            reOrdList.append([[line], maxisosize - size])

    csList = []
    for disc in [x[0] for x in reOrdList]:
        csList.extend(disc)
    return csList

if __name__ == '__main__':
    if len(sys.argv) != 2:
        usage()

    if not os.path.isdir(sys.argv[1]):
        usage()

    unified = sys.argv[1]

    f = open(join(unified, '.discinfo'))
    discinfo = [ line.strip() for line in f ]
    f.close()

    cslist = join(discinfo[4], 'cslist')
    csdir = discinfo[5]

    # create disc1, it needs to contain all the disc1 files
    current = join(os.path.dirname(unified), 'disc1')
    discnum = 1
    if os.path.isdir(current):
        print >> sys.stderr, 'removing stale', current
        util.rmtree(current)
    print >> sys.stderr, 'creating', current
    os.mkdir(current)
    lndir(unified, current, excludes=(csdir, cslist, '.discinfo'))
    writediscinfo(current, discnum, discinfo)
    used = spaceused(current)

    # iterate through the cslist, copying all the changesets that
    # will fit
    f = open(join(unified, cslist))
    outcs = open(join(current, cslist), 'w')
    reOrd = reorderChangesets(f, join(unified, csdir), used)
    f.close()
    for line in reOrd:
        csfile = line.split()[0]
        src = join(unified, csdir, csfile)
        used += spaceused(src)
        if used > maxisosize:
            # oops, ran out of space.  set up a new disc
            discnum += 1
            current = join(os.path.dirname(unified), 'disc%d' %discnum)
            preparedir(unified, current, csdir)
            writediscinfo(current, discnum, discinfo)
            used = spaceused(current) + spaceused(src)
        dest = join(current, csdir, csfile)
        os.link(src, dest)
        # cut off disc number, record the disc location
        newline = " ".join(line.split()[:-1])
        outcs.write("%s %d\n" %(newline, discnum))
    outcs.close()


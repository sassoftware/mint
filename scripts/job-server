#!/usr/bin/python
#
# Copyright (c) 2004-2005 Specifix, Inc.
#
# All Rights Reserved
#

import errno
import re
import sys
import os
import time
import threading

import conary
import conarycfg
import conaryclient
from conarycfg import ConfigFile, ConaryConfiguration
from deps import deps
from lib import log
from lib import util
sys.excepthook = util.genExcepthook()

sys.path.append("..")

import imagetool
from imagetool import jobs
import jobstatus
import profiletypes

scriptPath = os.path.dirname(sys.argv[0])
if not scriptPath:
    scriptPath = '.'

class JobRunner(threading.Thread):
    def __init__(self, cfg, client, job):
        threading.Thread.__init__(self)
        self.cfg = cfg
        self.client = client
        self.job = job

    def run(self):
        jobId = self.job.getId()
        profileId = self.job.getProfileId()
        profile = self.client.getProfile(profileId)
        project = self.client.getProject(profile.getProjectId())
        
        self.job.setStatus(jobstatus.RUNNING, 'Running')
        log.info("job %d running", jobId)

        try:
            try:
                os.makedirs(self.cfg.imagesPath)
            except OSError, err:
                if err.errno != errno.EEXIST:
                    raise
            generator = profiletypes.generators[profile.getImageType()]
            imageFilenames = generator(self.client, self.cfg, self.job, profileId).write()
        except Exception, e:
            self.job.setStatus(jobstatus.ERROR, str(e))
            raise
        else:
            profile.setFiles(imageFilenames)
            self.job.setStatus(jobstatus.FINISHED, "Finished")
            log.info("job %d finished: %s", jobId, str(imageFilenames))

class JobDaemon:
    def __init__(self, cfgFile):
        cfg = imagetool.ImageToolConfig()
        cfg.read(cfgFile)
        
        client = imagetool.ImageToolClient(cfg.serverUrl)
       
        threads = []

        try:
            os.makedirs(cfg.logPath)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise
     
        # normalize the job daemon machine's architecture
        # right now we only handle x86 and x86_64 images
        arch = os.uname()[4]
        
        x86_re = re.compile('i.86')
        if x86_re.match(arch):
            arch = "x86"
        elif arch == "x86_64":
            pass
        else:
            log.error("unsupported architecture: %s", arch)
            sys.exit(1)

        log.info("handling jobs of architecture: %s", arch)
        
        while(True):
            joblist = list(client.iterJobs(profileId=-1))

            for job in joblist:
                profile = client.getProfile(job.getProfileId())
            
                if job.getStatus() == jobstatus.WAITING\
                   and len(joblist) < 5\
                   and arch == profile.getArch():
                    th = JobRunner(cfg, client, job)
                    threads.append(th)
                    th.start()
            time.sleep(5)

if __name__ == "__main__":
    lockFile = "/var/run/imagetool-jobdaemon.pid"
    
    # use sys.argv[1] as config file if provided
    # if not, use some standard locations
    cfgFiles = ["imagetool.conf", "../../imagetool.conf", None]
    if len(sys.argv) > 1:
        if os.access(sys.argv[1], os.R_OK) and os.path.isfile(sys.argv[1]):
            cfgFile = sys.argv[1]
        else:
            log.error("unable to open config file: %s", sys.argv[1])
            sys.exit(1)

    for cfgFile in cfgFiles:
        if cfgFile:
            if os.access(cfgFile, os.R_OK) and os.path.isfile(cfgFile):
                break
        else:
            print >> sys.stderr, "Usage: %s [config file]" % (sys.argv[0])
     
    if os.access(lockFile, os.R_OK):
        lock = open(lockFile, "r")
        pid = lock.read()
        log.error("imagetool job daemon already running as pid %s", pid)
        sys.exit(1)
   
    log.info("loading configuration file: %s", cfgFile)

    try:
        lock = open(lockFile, "w")
        lock.write("%d" % os.getpid())
        lock.close()
    except:
        log.warning("unable to open lockfile: %s", lockFile)
    
    try:
        print "job daemon started (pid %d)" % os.getpid()
        jd = JobDaemon(cfgFile)
    except:
        log.info("exiting")
        try:
            os.unlink(lockFile)
        except OSError:
            log.warning("unable to remove lockfile: %s", lockFile)
        raise

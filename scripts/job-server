#
# Copyright (c) 2004-2005 Specifix, Inc.
#
# All Rights Reserved
#

import errno
import sys
import os
import time
import tempfile
import threading
import subprocess

if os.environ.has_key("CONARY_PATH"):
    sys.path.insert(0, os.environ['CONARY_PATH'])
else:
    sys.path.insert(-1, "/usr/share/conary/")

import imagetool
import jobstatus
import jobtypes
import jobs

import conarycfg
import conaryclient
from conarycfg import ConfigFile, ConaryConfiguration
from deps import deps

scriptPath = os.path.dirname(sys.argv[0])
if not scriptPath:
    scriptPath = '.'

class Journal:
    def lchown(self, root, target, user, group):
        # get rid of the root
        target = target[len(root):]
        dirname = os.path.dirname(target)
        filename = os.path.basename(target)
        f = open(os.sep.join((root, dirname, '.UIDGID')), 'a')
        # XXX e2fsimage does not handle group lookups yet
        f.write('%s %s\n' %(filename, user))
        f.close()

    def mknod(self, root, target, devtype, major, minor, mode,
              uid, gid):
        # get rid of the root
        target = target[len(root):]
        dirname = os.path.dirname(target)
        filename = os.path.basename(target)
        f = open(os.sep.join((root, dirname, '.DEVICES')), 'a')
        # XXX e2fsimage does not handle symbolic users/groups for .DEVICES
        f.write('%s %s %d %d 0%o\n' %(filename, devtype, major, minor, mode))
        f.close()

class JobRunner(threading.Thread):
    def __init__(self, cfg, client, job):
        threading.Thread.__init__(self)
        self.cfg = cfg
        self.client = client
        self.job = job

    def run(self):
        jobId = self.job.getId()
        profileId = self.job.getProfile()
        projectId, name = self.client.getProfile(profileId)
        project = self.client.getProject(profileId)
        
        self.client.setJobStatus(jobId, jobstatus.RUNNING)
        print "set %d running" % jobId

        try:
            try:
                os.makedirs(self.cfg.imagesPath)
            except OSError, err:
                if err.errno != errno.EEXIST:
                    raise
            generator = jobtypes.generators[self.job.getType()]
            imageFilenames = generator(self.client, self.cfg, self.job, profileId).write()
        except:
            self.client.setJobStatus(jobId, jobstatus.ERROR)
            raise
        else:
            self.client.setJobFilename(jobId, filenames.join(";"))
            self.client.setJobStatus(jobId, jobstatus.FINISHED)
            print "set %d finished (%s)" % (jobId, tmpDir)

class JobDaemon:
    def __init__(self, cfgFile):
        cfg = imagetool.ImageToolConfig()
        cfg.read(cfgFile)
        
        client = imagetool.ImageToolClient(cfg.imagetoolUrl)
       
        threads = []
        
        while(True):
            try:
                joblist = list(client.iterPendingJobs())
            except jobs.JobMissing:
                joblist = []

            for job in joblist:
                if len(threads) >= cfg.concurrentJobs:
                    break

                th = JobRunner(cfg, client, job)
                threads.append(th)
                th.start()
            time.sleep(5)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print >> sys.stderr, "Usage: %s [config file]" % (sys.argv[0])
        sys.exit(1)
    else:
        cfgFile = sys.argv[1]
        jd = JobDaemon(cfgFile)

#!/usr/bin/python
#
# Copyright (c) 2004-2005 Specifix, Inc.
#
# All Rights Reserved
#

import errno
import re
import signal
import socket
import sys
import os
import time
import threading

from optparse import OptionParser

import conary
import conarycfg
import conaryclient
from conarycfg import ConfigFile, ConaryConfiguration
from deps import deps
from lib import log
from lib import util

# to run from CVS
sys.path.append('..')

import imagetool
from imagetool.imagetool import ImageToolConfig
from imagetool.imagetool import ImageToolClient
from imagetool import jobs
from imagetool import jobstatus
from imagetool import profiletypes

# image generators
from imagetool.distro.installable_iso import InstallableIso
from imagetool.distro.live_iso import LiveIso
from imagetool.distro.live_cf_image import LiveCFImage
from imagetool.distro.stub_image import StubImage

generators = {
    profiletypes.LIVE_ISO:           LiveIso,
    profiletypes.INSTALLABLE_ISO:    InstallableIso,
    profiletypes.LIVE_CF_IMAGE:      LiveCFImage,
    profiletypes.STUB_IMAGE:         StubImage,
}

class JobRunner(threading.Thread):
    def __init__(self, cfg, client, job):
        threading.Thread.__init__(self)
        self.cfg = cfg
        self.client = client
        self.job = job

    def run(self):
        jobId = self.job.getId()
        profileId = self.job.getProfileId()
        profile = self.client.getProfile(profileId)
        project = self.client.getProject(profile.getProjectId())
        
        self.job.setStatus(jobstatus.RUNNING, 'Running')
        log.info("job %d started", jobId)

        try:
            try:
                os.makedirs(self.cfg.imagesPath)
            except OSError, err:
                if err.errno != errno.EEXIST:
                    raise
            generator = generators[profile.getImageType()]
            imageFilenames = generator(self.client, self.cfg, self.job, profileId).write()
        except Exception, e:
            self.job.setStatus(jobstatus.ERROR, str(e))
            raise
        else:
            profile.setFiles(imageFilenames)
            self.job.setStatus(jobstatus.FINISHED, "Finished")
            log.info("job %d finished: %s", jobId, str(imageFilenames))

class JobDaemon:
    def __init__(self, cfg):
        client = ImageToolClient(cfg.serverUrl)
       
        threads = []

        try:
            os.makedirs(cfg.logPath)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise
     
        # normalize the job daemon machine's architecture
        # right now we only handle x86 and x86_64 images
        arch = os.uname()[4]
        
        x86_re = re.compile('i.86')
        if x86_re.match(arch):
            arch = "x86"
        elif arch == "x86_64":
            pass
        else:
            log.error("unsupported architecture: %s", arch)
            sys.exit(1)

        log.info("handling jobs of architecture: %s", arch)
        
        while(True):
            joblist = list(client.iterJobs(profileId=-1))

            for job in joblist:
                profile = client.getProfile(job.getProfileId())
                if job.getStatus() == jobstatus.WAITING\
                   and len(joblist) < 5\
                   and arch == profile.getArch():
                    th = JobRunner(cfg, client, job)
                    threads.append(th)
                    th.start()
            time.sleep(5)

def kill(lockFile):
    lock = open(lockFile, "r")
    pid = int(lock.read())
    lock.close()
    log.info("killing job server pid %d" % pid)
    try:
        os.kill(pid, signal.SIGINT)
    except OSError, e:
        log.info("process not found; removing lock file")
        if e.errno != errno.ESRCH:
            os.unlink(lockFile)
        else:
            raise

def daemon(options, cfg, lockFile):
    try:
        lock = open(lockFile, "w")
        lock.write("%d" % os.getpid())
        lock.close()
    except:
        log.warning("unable to open lockfile: %s", lockFile)
    
    try:
       
        jd = JobDaemon(cfg)
    except socket.error, msg:
        log.error("connecting to Imagetool XMLRPC server: %s", msg[1])
    except KeyboardInterrupt:
        log.info("interrupt caught; exiting")

    try:
        os.unlink(lockFile)
    except OSError:
        log.warning("unable to remove lockfile: %s", lockFile)

if __name__ == "__main__":
    lockFile = "/var/run/imagetool-jobdaemon.pid"
    
    parser = OptionParser()
    parser.add_option("-k", "--kill", dest = "kill",
                      action = "store_true",
                      help = "Kill the running job daemon.")
    parser.add_option("-c", "--config", dest = "config", default = None,
                      help = "Location of the Imagetool configuration file.")
    parser.add_option("-d", "--debug", dest = "debug", action = "store_true",
                      help = "Enable the debugger on errors.")
    (options, args) = parser.parse_args()

    if options.debug:
        sys.excepthook = util.genExcepthook()
        log.setVerbosity(log.DEBUG)
    else: 
        log.setVerbosity(log.INFO)
    
    if options.kill:
        kill(lockFile)
        sys.exit(1)
    
    # use sys.argv[1] as config file if provided
    # if not, try some standard locations
    cfgFiles = ["imagetool.conf", "../imagetool.conf", None]
    if options.config:
        if os.access(sys.argv[1], os.R_OK) and os.path.isfile(sys.argv[1]):
            cfgFile = sys.argv[1]
        else:
            log.error("unable to open config file: %s", sys.argv[1])
            sys.exit(1)

    for cfgFile in cfgFiles:
        if cfgFile:
            if os.access(cfgFile, os.R_OK) and os.path.isfile(cfgFile):
                break
        else:
            log.error("unable to open imagetool.conf configuration file. Please use --config=<path>.")
    
    if os.access(lockFile, os.R_OK):
        lock = open(lockFile, "r")
        pid = lock.read()
        log.error("Imagetool job daemon already running as pid %s", pid)
        sys.exit(1)
   
    log.debug("loading configuration file: %s", cfgFile)
    log.info("using Conary in %s", os.path.dirname(sys.modules['conary'].__file__))
    cfg = ImageToolConfig()
    cfg.read(cfgFile)

    pid = os.fork()

    if pid == 0:
        os.setsid()
        pid = os.fork()
        if pid == 0:
            logFile = os.path.join(cfg.logPath, "job-server.log")
            logfd = os.open(logFile, os.O_APPEND | os.O_WRONLY | os.O_CREAT)
            sys.stdout.flush()
            sys.stderr.flush()

            stdout = os.dup(sys.stdout.fileno())
            stderr = os.dup(sys.stderr.fileno())
            os.dup2(logfd, sys.stdout.fileno())
            os.dup2(logfd, sys.stderr.fileno())
            
            daemon(options, cfg, lockFile)
    else:
        log.info("Imagetool job server started")
        os._exit(0)

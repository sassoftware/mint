#!/usr/bin/python
#
# Copyright (c) 2004-2005 rpath, Inc.
#
# All Rights Reserved
#

import errno
import re
import signal
import socket
import sys
import os
import time
import threading

from optparse import OptionParser

import conary
import conarycfg
import conaryclient
from conarycfg import ConfigFile, ConaryConfiguration
from deps import deps
from lib import log
from lib import util

# to run from CVS
sys.path.append('..')

from mint.config import MintConfig
from mint.mint import MintClient 
from mint import jobs
from mint import jobstatus
from mint import releasetypes

# image generators
from mint.distro.installable_iso import InstallableIso
from mint.distro.live_iso import LiveIso
from mint.distro.live_cf_image import LiveCFImage
from mint.distro.stub_image import StubImage
from mint.distro.netboot_image import NetbootImage

generators = {
    releasetypes.LIVE_ISO:           LiveIso,
    releasetypes.INSTALLABLE_ISO:    InstallableIso,
    releasetypes.LIVE_CF_IMAGE:      LiveCFImage,
    releasetypes.STUB_IMAGE:         StubImage,
    releasetypes.NETBOOT_IMAGE:      NetbootImage,
}

class JobRunner(threading.Thread):
    def __init__(self, cfg, client, job):
        threading.Thread.__init__(self)
        self.cfg = cfg
        self.client = client
        self.job = job

    def run(self):
        jobId = self.job.getId()
        releaseId = self.job.getReleaseId()
        release = self.client.getRelease(releaseId)
        project = self.client.getProject(release.getProjectId())
        
        self.job.setStatus(jobstatus.RUNNING, 'Running')
        log.info("job %d started", jobId)

        try:
            try:
                os.makedirs(self.cfg.imagesPath)
            except OSError, err:
                if err.errno != errno.EEXIST:
                    raise
            generator = generators[release.getImageType()]
            imageFilenames = generator(self.client, self.cfg, self.job, releaseId).write()
        except Exception, e:
            self.job.setStatus(jobstatus.ERROR, str(e))
            raise
        else:
            release.setFiles(imageFilenames)
            self.job.setStatus(jobstatus.FINISHED, "Finished")
            log.info("job %d finished: %s", jobId, str(imageFilenames))

class JobDaemon:
    def __init__(self, cfg, serverUrl):
        client = MintClient(serverUrl)
       
        threads = []

        try:
            os.makedirs(cfg.logPath)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise
     
        # normalize the job daemon machine's architecture
        # right now we only handle x86 and x86_64 images
        arch = os.uname()[4]
        
        x86_re = re.compile('i.86')
        if x86_re.match(arch):
            arch = "x86"
        elif arch == "x86_64":
            pass
        else:
            log.error("unsupported architecture: %s", arch)
            sys.exit(1)

        log.info("handling jobs of architecture: %s", arch)
        
        while(True):
            joblist = list(client.iterJobs(releaseId=-1))
            
            for job in joblist:
                release = client.getRelease(job.getReleaseId())
                if job.getStatus() == jobstatus.WAITING\
                   and arch == release.getArch():
                    th = JobRunner(cfg, client, job)
                    threads.append(th)
                    th.start()
            time.sleep(5)

def kill(lockFile):
    try:
        lock = open(lockFile, "r")
        pid = int(lock.read())
        lock.close()
    except:
        log.warning("unable to open lockfile: %s", lockFile)
    else:
        log.info("killing job server pid %d" % pid)
        try:
            os.kill(pid, signal.SIGINT)
        except OSError, e:
            if e.errno != errno.ESRCH:
                raise
            else:
                log.info("process not found; removing lock file")
                os.unlink(lockFile)
        else:
            try:
                os.unlink(lockFile)
            except OSError, IOError:
                log.warning("unable to remove lockfile")

def daemon(options, cfg, serverUrl, lockFile):
    try:
        lock = open(lockFile, "w")
        lock.write("%d" % os.getpid())
        lock.close()
    except:
        log.warning("unable to open lockfile: %s", lockFile)
    
    try:
       
        jd = JobDaemon(cfg, serverUrl)
    except socket.error, msg:
        log.error("connecting to Mint XMLRPC server: %s", msg[1])
    except KeyboardInterrupt:
        log.info("interrupt caught; exiting")

    try:
        os.unlink(lockFile)
    except IOError, OSError:
        log.warning("unable to remove lockfile: %s", lockFile)

if __name__ == "__main__":
    lockFile = "/var/run/mint-jobdaemon.pid"
    
    parser = OptionParser()
    parser.add_option("-k", "--kill", dest = "kill",
                      action = "store_true",
                      help = "Kill the running job daemon.")
    parser.add_option("-c", "--config", dest = "config", default = None,
                      help = "Location of the Mint configuration file.")
    parser.add_option("-d", "--debug", dest = "debug", action = "store_true",
                      help = "Enable the debugger on errors.")
    (options, args) = parser.parse_args()
    
    if not args:
        log.error("You must specify the URL to an mint XMLRPC server on the command line.")
        sys.exit(1)
    
    if options.debug:
        sys.excepthook = util.genExcepthook()
        log.setVerbosity(log.DEBUG)
    else: 
        log.setVerbosity(log.INFO)
    
    if options.kill:
        kill(lockFile)
        sys.exit(1)
    
    # use sys.argv[1] as config file if provided
    # if not, try some standard locations
    cfgFiles = ["mint.conf", "../mint.conf", None]
    if options.config:
        cfgFile = options.config
    else:
        for cfgFile in cfgFiles:
            if cfgFile:
                if os.access(cfgFile, os.R_OK) and os.path.isfile(cfgFile):
                    break
            else:
                log.error("unable to open mint.conf configuration file. Please use --config=<path>.")
    
    if os.access(lockFile, os.R_OK):
        lock = open(lockFile, "r")
        pid = lock.read()
        log.error("Mint job daemon already running as pid %s", pid)
        sys.exit(1)
   
    log.debug("loading configuration file: %s", cfgFile)
    log.info("using Conary in %s", os.path.dirname(sys.modules['conary'].__file__))
    cfg = MintConfig()
    cfg.read(cfgFile)

    pid = os.fork()

    if pid == 0:
        os.setsid()
        pid = os.fork()
        if pid == 0:
            logFile = os.path.join(cfg.logPath, "job-server.log")
            logfd = os.open(logFile, os.O_APPEND | os.O_WRONLY | os.O_CREAT)
            sys.stdout.flush()
            sys.stderr.flush()

            stdout = os.dup(sys.stdout.fileno())
            stderr = os.dup(sys.stderr.fileno())
            os.dup2(logfd, sys.stdout.fileno())
            os.dup2(logfd, sys.stderr.fileno())
            
            daemon(options, cfg, args[0], lockFile)
    else:
        log.info("Mint job server started")
        os._exit(0)

#!/usr/bin/python
#
# Copyright (c) 2004-2006 rPath, Inc.
#
# All Rights Reserved
#

import errno
import signal
import socket
import sys
import os
import logging
from optparse import OptionParser

from conary.lib import util
from mint import scriptlibrary

from mint.distro import jobserver

def kill(lockFile):
    log = scriptlibrary.getScriptLogger()
    try:
        lock = open(lockFile, "r")
        pid = int(lock.readline())
        lock.close()
    except Exception, e:
        log.warning("unable to open lockfile: %s (%s)", lockFile, str(e))
    else:
        pipeFD = os.popen("ps p %d -o 'comm= args='" %pid)
        procName = pipeFD.readline().strip()
        pipeFD.close()
        if sys.argv[0] not in procName:
            log.error("pid: %d does not seem to be an rBuilder"
            " ISO generation server." % pid)
            try:
                log.info("removing lock file")
                os.unlink(lockFile)
            except OSError, e:
                pass
            return
        log.info("killing rBuilder ISO generation server pid %d" % pid)
        try:
            os.kill(pid, signal.SIGINT)
        except OSError, e:
            if e.errno != errno.ESRCH:
                raise
            else:
                log.info("process not found; removing lock file")
                os.unlink(lockFile)
        # note, the lock file is not removed if an interrupt signal is
        # sucessfully sent. the rBuilder isogen server will remove the lock
        # on it's own once it has finsihed processing.

def daemon(options, cfg):
    log = scriptlibrary.getScriptLogger()
    try:
        lock = open(cfg.lockFile, "w")
        lock.write("%d" % os.getpid())
        lock.close()
    except Exception, e:
        log.warning("unable to open lockfile: %s (%s)", cfg.lockFile, str(e))
    try:
        jd = jobserver.JobDaemon(cfg)
    except socket.error, msg:
        log.error("connecting to rBuilder server: %s", msg[1])
    except KeyboardInterrupt:
        log.info("interrupt caught; exiting")

    try:
        os.unlink(cfg.lockFile)
    except (IOError, OSError):
        log.warning("unable to remove lockfile: %s", cfg.lockFile)


if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-k", "--kill", dest = "kill",
                      action = "store_true",
                      help = "Kill the running ISO generation server.")
    parser.add_option("-c", "--config", dest = "config", default = None,
                      help = "Location of the iso_gen.conf file.")
    parser.add_option("-d", "--debug", dest = "debug", action = "store_true",
                      help = "Enable the debugger on errors.")
    parser.add_option("-n", "--no-daemon", dest = "noDaemon",
                      action = "store_true", default = False,
                      help = "Do not run as a daemon")
    (options, args) = parser.parse_args()

    log = scriptlibrary.getScriptLogger()

    # use sys.argv[1] as config file if provided
    # if not, try some standard locations
    cfgFiles = ["iso_gen.conf", None]
    if options.config:
        cfgFile = options.config
    else:
        for cfgFile in cfgFiles:
            if cfgFile:
                if os.access(cfgFile, os.R_OK) and os.path.isfile(cfgFile):
                    break
    if not cfgFile:
        log.error("Unable to open iso_gen.conf configuration " \
                  "file. Please use --config=<path>.")
        sys.exit(1)

    cfg = jobserver.IsoGenConfig()
    cfg.read(cfgFile)

    if options.debug or options.noDaemon:
        logfileLevel = logging.DEBUG
        cfg.saveChildOutput = True
        cfg.debug = True
    else:
        logfileLevel = logging.INFO
        cfg.saveChildOutput = False

    if options.noDaemon:
        consoleLevel = logging.DEBUG
    else:
        consoleLevel = logging.WARNING

    # create log instance
    scriptlibrary.setupScriptLogger(os.path.join(cfg.logPath, "job-server.log"),
            consoleLevel, logfileLevel)

    log.debug("loaded configuration file: %s", cfgFile)

    if options.kill:
        kill(cfg.lockFile)
        sys.exit(1)

    if os.access(cfg.lockFile, os.R_OK):
        lock = open(cfg.lockFile, "r")
        pid = int(lock.readline())
        lock.close()
        # check if the pid is actually valid...
        pipeFD = os.popen("ps -p %d -o pid="% pid)
        pidLine = pipeFD.readline()
        pipeFD.close()

        if str(pid) in pidLine:
            log.error("rBuilder ISO generation server already"
                      " running as pid %d", pid)
            sys.exit(1)
        else:
            log.info("Old job daemon pid seems to be invalid. killing.")
            kill(cfg.lockFile)

    log.info("using Conary in %s",
             os.path.dirname(sys.modules['conary'].__file__))

    if options.noDaemon:
        sys.excepthook = util.genExcepthook()
        cfg.maxThreads = 1
        daemon(options, cfg)
    else:
        pid = os.fork()

        # no longer write to console in daemon mode
        nullfd = os.open('/dev/null', os.O_WRONLY)
        os.dup2(nullfd, sys.stderr.fileno())
        os.dup2(nullfd, sys.stdout.fileno())
        os.dup2(nullfd, sys.stdin.fileno())
        os.close(nullfd)

        if pid == 0:
            pid = os.fork()

            if pid == 0:
                # abandon the controlling tty by resetting session id
                os.setsid()
                daemon(options, cfg)
        else:
            log.info("rBuilder ISO generation server started")
            os._exit(0)

#!/usr/bin/python
#
# Copyright (c) 2004-2006 rPath, Inc.
#
# All Rights Reserved
#

import errno
import signal
import socket
import sys
import os
from optparse import OptionParser

from conary.lib import log, util

from mint.distro import jobserver


def kill(lockFile):
    try:
        lock = open(lockFile, "r")
        pid = int(lock.readline())
        lock.close()
    except Exception, e:
        log.warning("unable to open lockfile: %s (%s)", lockFile, str(e))
    else:
        pipeFD = os.popen("ps p %d -o 'comm= args='" %pid)
        procName = pipeFD.readline().strip()
        pipeFD.close()
        if sys.argv[0] not in procName:
            log.error("pid: %d does not seem to be an rBuilder"
            " ISO generation server." % pid)
            try:
                log.info("removing lock file")
                os.unlink(lockFile)
            except OSError, e:
                pass
            return
        log.info("killing rBuilder ISO generation server pid %d" % pid)
        try:
            os.kill(pid, signal.SIGINT)
        except OSError, e:
            if e.errno != errno.ESRCH:
                raise
            else:
                log.info("process not found; removing lock file")
                os.unlink(lockFile)
        # note, the lock file is not removed if an interrupt signal is
        # sucessfully sent. the rBuilder isogen server will remove the lock
        # on it's own once it has finsihed processing.

def daemon(options, cfg):
    try:
        lock = open(cfg.lockFile, "w")
        lock.write("%d" % os.getpid())
        lock.close()
    except Exception, e:
        log.warning("unable to open lockfile: %s (%s)", cfg.lockFile, str(e))
    try:
        jd = jobserver.JobDaemon(cfg)
    except socket.error, msg:
        log.error("connecting to rBuilder server: %s", msg[1])
    except KeyboardInterrupt:
        log.info("(%d) interrupt caught; exiting" % os.getpid())

    try:
        os.unlink(cfg.lockFile)
    except (IOError, OSError):
        log.warning("unable to remove lockfile: %s", cfg.lockFile)


if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-k", "--kill", dest = "kill",
                      action = "store_true",
                      help = "Kill the running ISO generation server.")
    parser.add_option("-c", "--config", dest = "config", default = None,
                      help = "Location of the iso_gen.conf file.")
    parser.add_option("-d", "--debug", dest = "debug", action = "store_true",
                      help = "Enable the debugger on errors.")
    parser.add_option("-n", "--no-daemon", dest = "noDaemon",
                      action = "store_true", default = False,
                      help = "Do not run as a daemon")
    (options, args) = parser.parse_args()

    if options.debug:
        sys.excepthook = util.genExcepthook()
        log.setVerbosity(log.DEBUG)
    else:
        log.setVerbosity(log.INFO)

    # use sys.argv[1] as config file if provided
    # if not, try some standard locations
    cfgFiles = ["iso_gen.conf", None]
    if options.config:
        cfgFile = options.config
    else:
        for cfgFile in cfgFiles:
            if cfgFile:
                if os.access(cfgFile, os.R_OK) and os.path.isfile(cfgFile):
                    break
    if not cfgFile:
        log.error("unable to open iso_gen.conf configuration file."
                  " Please use --config=<path>.")
        sys.exit(1)

    cfg = jobserver.IsoGenConfig()
    cfg.read(cfgFile)

    if options.kill:
        kill(cfg.lockFile)
        sys.exit(1)

    if os.access(cfg.lockFile, os.R_OK):
        lock = open(cfg.lockFile, "r")
        pid = int(lock.readline())
        lock.close()
        # check if the pid is actually valid...
        pipeFD = os.popen("ps -p %d -o pid="% pid)
        pidLine = pipeFD.readline()
        pipeFD.close()

        if str(pid) in pidLine:
            log.error("rBuilder ISO generation server already"
                      " running as pid %d", pid)
            sys.exit(1)
        else:
            log.info("Old job daemon pid seems to be invalid. killing.")
            kill(cfg.lockFile)

    log.debug("(%d) loading configuration file: %s", os.getpid(), cfgFile)
    log.info("using Conary in %s",
             os.path.dirname(sys.modules['conary'].__file__))

    if options.noDaemon:
        sys.excepthook = util.genExcepthook()
        daemon(options, cfg)
    else:
        pid = os.fork()

        if pid == 0:
            # redirect stdout and stderr to job-server.log
            logFile = os.path.join(cfg.logPath, "job-server.log")
            null = os.open("/dev/null", os.O_WRONLY)
            logfd = os.open(logFile, os.O_APPEND | os.O_WRONLY | os.O_CREAT, 0666)
            os.dup2(logfd, sys.stdout.fileno())
            os.dup2(logfd, sys.stderr.fileno())
            os.dup2(null, sys.stdin.fileno())
            os.close(null)

            pid = os.fork()
            if pid == 0:
                # abandon the controlling tty by resetting session id
                os.setsid()

                sys.stdout.flush()
                sys.stderr.flush()

                daemon(options, cfg)
        else:
            log.info("(%d) rBuilder ISO generation server started", os.getpid())
            os._exit(0)

#!/usr/bin/python
#
# Copyright (c) 2004-2005 rPath, Inc.
#
# All Rights Reserved
#

import errno
import re
import signal
import socket
import sys
import os
import time
import threading

from xmlrpclib import ProtocolError
from optparse import OptionParser

import conary
import conarycfg
import conaryclient
from conarycfg import ConfigFile, ConaryConfiguration
from conarycfg import STRINGLIST, BOOLEAN
from deps import deps
from lib import log
from lib import util

# to run from CVS
sys.path.append('..')

from mint.mint import MintClient 
from mint import jobs
from mint import jobstatus
from mint import releasetypes

# image generators
from mint.distro.installable_iso import InstallableIso
from mint.distro.live_iso import LiveIso
from mint.distro.live_cf_image import LiveCFImage
from mint.distro.stub_image import StubImage
from mint.distro.netboot_image import NetbootImage
from mint.distro.cleanup import Cleanup

generators = {
    releasetypes.LIVE_ISO:           LiveIso,
    releasetypes.INSTALLABLE_ISO:    InstallableIso,
    releasetypes.LIVE_CF_IMAGE:      LiveCFImage,
    releasetypes.STUB_IMAGE:         StubImage,
    releasetypes.NETBOOT_IMAGE:      NetbootImage,
    releasetypes.CLEANUP:            Cleanup, 
}

SUPPORTED_ARCHS = ('x86', 'x86_64')

class JobRunner(threading.Thread):
    def __init__(self, cfg, client, job):
        threading.Thread.__init__(self)
        self.cfg = cfg
        self.client = client
        self.job = job
        # still in parent thread when init gets called.
        self.parentThread = threading.currentThread()

    def run(self):
        jobId = self.job.getId()
        releaseId = self.job.getReleaseId()
        release = self.client.getRelease(releaseId)
        project = self.client.getProject(release.getProjectId())
        
        self.job.setStatus(jobstatus.RUNNING, 'Running')

        try:
            generator = generators[release.getImageType()]
            log.info("%s job for %s started (id %d)" % (generator.__name__, project.getHostname(), jobId))
            
            # save the current working directory in case the generator 
            # (or scripts that change the wd)
            cwd = os.getcwd()
            imageFilenames = generator(self.client, self.cfg, self.job, releaseId).write()
            os.chdir(cwd)
        except Exception, e:
            self.job.setStatus(jobstatus.ERROR, str(e))
            raise
        else:
            release.setFiles(imageFilenames)
            self.job.setStatus(jobstatus.FINISHED, "Finished")
            log.info("job %d finished: %s", jobId, str(imageFilenames))

class JobDaemon:
    def __init__(self, cfg):
        client = MintClient(cfg.serverUrl)

        confirmedAlive = False

        try:
            os.makedirs(cfg.logPath)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise
     
        # normalize the job daemon machine's architecture
        # right now we only handle x86 and x86_64 images
        log.info("handling jobs of architecture: %s", cfg.supportedArch)
        
        while(True):
            try:
                joblist = list(client.iterJobs(releaseId=-1))
                confirmedAlive = True
                for job in joblist:
                    release = client.getRelease(job.getReleaseId())
                    if job.getStatus() == jobstatus.WAITING\
                           and release.getArch() in cfg.supportedArch:
                        th = JobRunner(cfg, client, job)
                        th.start()
                        # wait for this one to finish before starting more
                        th.join()
            # We can't assume the mint server will stay up forever.
            # We'd like to ignore exceptions raised if/when the mint server
            # dies, and just wait for it to come back up.
            # Sometimes we get socket.error and sometimes we get
            # a ProtocolError...
            # it all depends on what the xmlrpc lib was trying to do when
            # the server went byebye.
            except (ProtocolError, socket.error), e:
                if not confirmedAlive:
                    log.error("rBuilder Server Unreachable; exiting")
                    return
                log.warning("Error retrieving job list:" + str(e))
            time.sleep(5)

def kill(lockFile):
    try:
        lock = open(lockFile, "r")
        pid = int(lock.read())
        lock.close()
    except:
        log.warning("unable to open lockfile: %s", lockFile)
    else:
        pipeFD = os.popen("ps -p %d -o comm=" %pid)
        procName = pipeFD.readline().strip()
        pipeFD.close()
        if procName not in sys.argv[0]:
            log.error("pid: %d does not seem to be an rBuilder ISO generation server.")
            sys.exit(1)
        log.info("killing rBuilder ISO generation server pid %d" % pid)
        try:
            pass
            os.kill(pid, signal.SIGINT)
        except OSError, e:
            if e.errno != errno.ESRCH:
                raise
            else:
                log.info("process not found; removing lock file")
                os.unlink(lockFile)
        else:
            try:
                os.unlink(lockFile)
            except OSError, e:
                pass

def daemon(options, cfg):
    try:
        lock = open(cfg.lockFile, "w")
        lock.write("%d" % os.getpid())
        lock.close()
    except:
        log.warning("unable to open lockfile: %s", cfg.lockFile)
    
    try:
       
        jd = JobDaemon(cfg)
    except socket.error, msg:
        log.error("connecting to rBuilder server: %s", msg[1])
    except KeyboardInterrupt:
        log.info("interrupt caught; exiting")

    try:
        os.unlink(cfg.lockFile)
    except IOError, OSError:
        log.warning("unable to remove lockfile: %s", cfg.lockFile)

class IsoGenConfig(ConfigFile):
    defaults = {
        'supportedArch'   : [ STRINGLIST, [] ],
        'serverUrl'       : None,
        'logPath'         : '/srv/mint/logs',
        'imagesPath'      : '/srv/mint/images/',
        'lockFile'        : '/var/run/mint-jobdaemon.pid',
        }

    def read(self, path, exception = False):
        ConfigFile.read(self, path, exception)
        for arch in cfg.supportedArch:
            if arch not in SUPPORTED_ARCHS:
                log.error("unsupported architecture: %s", arch)
                sys.exit(1)
        if self.serverUrl is None:
            log.error("a server URL must be specified in the config file, for example:")
            log.error("serverUrl http://username:userpass@www.example.com/xmlrpc-private/")
            sys.exit(1)

if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-k", "--kill", dest = "kill",
                      action = "store_true",
                      help = "Kill the running ISO generation server.")
    parser.add_option("-c", "--config", dest = "config", default = None,
                      help = "Location of the iso_gen.conf file.")
    parser.add_option("-d", "--debug", dest = "debug", action = "store_true",
                      help = "Enable the debugger on errors.")
    (options, args) = parser.parse_args()
    
    if options.debug:
        sys.excepthook = util.genExcepthook()
        log.setVerbosity(log.DEBUG)
    else: 
        log.setVerbosity(log.INFO)

    # use sys.argv[1] as config file if provided
    # if not, try some standard locations
    cfgFiles = ["iso_gen.conf", None]
    if options.config:
        cfgFile = options.config
    else:
        for cfgFile in cfgFiles:
            if cfgFile:
                if os.access(cfgFile, os.R_OK) and os.path.isfile(cfgFile):
                    break
    if not cfgFile:
        log.error("unable to open iso_gen.conf configuration file. Please use --config=<path>.")
        sys.exit(1) 

    cfg = IsoGenConfig()
    cfg.read(cfgFile)

    # set up the cfg.configPath location so that the image generators
    # know where to look for their configuration files.
    cfg.configPath = os.path.dirname(cfgFile)

    if options.kill:
        kill(cfg.lockFile)
        sys.exit(1)

    if os.access(cfg.lockFile, os.R_OK):
        lock = open(cfg.lockFile, "r")
        pid = lock.read()
        lock.close()
        # check if the pid is actually valid...
        pipeFD = os.popen("ps -p %s -o pid="% pid)
        pidLine = pipeFD.readline()
        pipeFD.close()

        if pid in pidLine:
            log.error("rBuilder ISO generation server already running as pid %s", pid)
            sys.exit(1)
        else:
            log.info("Old job daemon pid seems to be invalid. killing.")
            kill(cfg.lockFile)

    log.debug("loading configuration file: %s", cfgFile)
    log.info("using Conary in %s", os.path.dirname(sys.modules['conary'].__file__))

    pid = os.fork()

    if pid == 0:
        # redirect stdout and stderr to job-server.log
        logFile = os.path.join(cfg.logPath, "job-server.log")
        nullf = file("/dev/null", "r+")
        logfd = os.open(logFile, os.O_APPEND | os.O_WRONLY | os.O_CREAT)
        os.dup2(logfd, sys.stdout.fileno())
        os.dup2(logfd, sys.stderr.fileno())
        os.dup2(nullf.fileno(), sys.stdin.fileno())
        nullf.close()
    
        pid = os.fork()
        if pid == 0:
            # abandon the controlling tty totally by placing this thread in a
            # new session
            os.setsid()

            sys.stdout.flush()
            sys.stderr.flush()
            
            daemon(options, cfg)
    else:
        log.info("rBuilder ISO generation server started")
        os._exit(0)

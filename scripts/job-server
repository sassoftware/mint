#!/usr/bin/python
#
# Copyright (c) 2004-2005 Specifix, Inc.
#
# All Rights Reserved
#

import errno
import re
import sys
import os
import time
import threading

if os.environ.has_key("CONARY_PATH"):
    sys.path.insert(0, os.environ['CONARY_PATH'])
else:
    sys.path.insert(-1, "/data/imagetool/code/conary/")
sys.path.insert(-1, "../")

from lib import util
sys.excepthook = util.genExcepthook()

from imagetool import imagetool
import jobstatus
import jobtypes
from imagetool import jobs

import conarycfg
import conaryclient
from conarycfg import ConfigFile, ConaryConfiguration
from deps import deps

scriptPath = os.path.dirname(sys.argv[0])
if not scriptPath:
    scriptPath = '.'

class JobRunner(threading.Thread):
    def __init__(self, cfg, client, job):
        threading.Thread.__init__(self)
        self.cfg = cfg
        self.client = client
        self.job = job

    def run(self):
        jobId = self.job.getId()
        profileId = self.job.getProfileId()
        name, projectId = self.client.getProfile(profileId)
        project = self.client.getProject(projectId)
        
        self.client.setJobStatus(jobId, jobstatus.RUNNING)
        print "Job %d running" % jobId

        try:
            try:
                os.makedirs(self.cfg.imagesPath)
            except OSError, err:
                if err.errno != errno.EEXIST:
                    raise
            generator = jobtypes.generators[self.job.getType()]
            imageFilenames = generator(self.client, self.cfg, self.job, profileId).write()
        except Exception, e:
            self.client.setJobStatus(jobId, jobstatus.ERROR, str(e))
            raise
        else:
            self.client.setJobFilenames(jobId, imageFilenames)
            self.client.setJobStatus(jobId, jobstatus.FINISHED)
            print "Job %d finished (%s)" % (jobId, imageFilenames)

class JobDaemon:
    def __init__(self, cfgFile):
        cfg = imagetool.ImageToolConfig()
        cfg.read(cfgFile)
        
        client = imagetool.ImageToolClient(cfg.serverUrl)
       
        threads = []

        try:
            os.makedirs(cfg.logPath)
        except OSError, e:
            if e.errno != errno.EEXIST:
                raise
     
        # normalize the job daemon machine's architecture
        # right now we only handle x86 and x86_64 images
        arch = os.uname()[4]
        
        x86_re = re.compile('i.86')
        if x86_re.match(arch):
            arch = "x86"
        elif arch == "x86_64":
            pass
        else:
            print >> sys.stderr, "Unsupported architecture:", arch
            sys.exit(1)

        print "Our architecture:", arch
        
        while(True):
            joblist = list(client.iterJobs(profileId=-1, arch=arch))

            for job in joblist:
                if job.getStatus() == jobstatus.WAITING:
                    th = JobRunner(cfg, client, job)
                    threads.append(th)
                    th.start()
            time.sleep(5)

if __name__ == "__main__":
    cfgFile = "imagetool.conf"
    lockFile = "/var/run/imagetool-jobdaemon.pid"
    
    if not os.access(cfgFile, os.R_OK): 
        if len(sys.argv) != 2:
            print >> sys.stderr, "Usage: %s [config file]" % (sys.argv[0])
            sys.exit(1)
        else:
            cfgFile = sys.argv[1]
    
    if os.access(lockFile, os.R_OK):
        lock = open(lockFile, "r")
        pid = lock.read()
        print >> sys.stderr, "Imagetool job daemon already running as pid %s" % (pid)
        sys.exit(0)
   
   
    print "Loading configuration file %s" % cfgFile
    lock = open(lockFile, "w")
    lock.write("%d" % os.getpid())
    lock.close()
    
    try:
        jd = JobDaemon(cfgFile)
    except:
        os.unlink(lockFile)
        raise

#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
import os
from os import _exit

from conary.conaryclient import mirror
from conary import versions
from conary.repository import netclient
from conary.lib import util, log

from mint import config
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorOutbound(MirrorScript):
    logFileName = "mirror-outbound.log"

    def action(self):
        client = MintClient(sys.argv[1])
        cfg = mirror.MirrorConfiguration()
        cfg.entitlementDirectory = None

        mintCfg = config.MintConfig()
        mintCfg.read(config.RBUILDER_CONFIG)
        mirroredLabels = client.getOutboundMirrors()

        for label in mirroredLabels:
            outboundMirrorId, projectId, sourceLabels, targetUrl, \
                targetUser, targetPass, mirrorAll, recurse, matchStrings = label
            projectId = int(projectId)
            sourceProject = client.getProject(projectId)
            sourceLabelId = sourceProject.getLabelIdMap().values()[0]
            self.log.info("Mirroring %s" % sourceProject.name)

            try:
                labelStr, _, sourceUser, sourcePass  = \
                          client.getLabel(sourceLabelId)
                reposHost = versions.Label(labelStr).getHost()
                sourceUrl = sourceProject.getConaryConfig().repositoryMap[reposHost]

                cfg.target.repositoryMap = {reposHost: targetUrl}
                cfg.target.user.addServerGlob(reposHost, targetUser, targetPass)

                cfg.source.repositoryMap = {reposHost: sourceUrl}
                cfg.source.user.addServerGlob(reposHost, sourceUser, sourcePass)

                cfg.host = reposHost

                if mirrorAll:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(labelStr)]

                cfg.configLine('matchTroves ' + ' '.join(matchStrings))

                targetRepos = netclient.NetworkRepositoryClient(cfg.target.repositoryMap,
                                      cfg.target.user,
                                      entitlementDir = cfg.entitlementDirectory)

                sourceRepos = netclient.NetworkRepositoryClient(cfg.source.repositoryMap,
                                      cfg.source.user,
                                      entitlementDir = cfg.entitlementDirectory)

                tmpDir = os.path.join(mintCfg.dataPath, 'tmp')
                if os.access(tmpDir, os.W_OK):
                    util.settempdir(tmpDir)

                while mirror.mirrorRepository(sourceRepos, targetRepos, cfg, False, False,
                                              False):
                    pass
            except Exception, e:
                self.log.error("Exception mirroring %s" % sourceProject.name)
                self.logTraceback()
        return 0

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())

#!/usr/bin/python2.4
#
# Copyright (c) 2006 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
from os import _exit

from conary.conaryclient import mirror
from conary import versions
from conary.repository import netclient
from conary.lib import util, log

from mint.client import MintClient
from mint.scriptlibrary import SingletonScript

log.setVerbosity(log.DEBUG)
sys.excepthook = util.genExcepthook(debug=True)

class MirrorOutbound(SingletonScript):

    def handle_args(self):
        if len(sys.argv) < 2:
            return False
        return True

    def usage(self):
        print "usage: %s <url to rBuilder server>" % self.name
        return 1

    def action(self):
        client = MintClient(sys.argv[1])
        cfg = mirror.MirrorConfiguration()

        mirroredLabels = client.getOutboundLabels()

        for label in mirroredLabels:
            projectId, sourceLabelId, targetUrl, targetUser, targetPass = label
            projectId = int(projectId)
            sourceLabelId = int(sourceLabelId)
            project = client.getProject(projectId)

            labelStr, _, sourceUser, sourcePass  = \
                      client.getLabel(sourceLabelId)
            reposHost = versions.Label(labelStr).getHost()
            sourceUrl = project.getConaryConfig().repositoryMap[reposHost]

            cfg.target.repositoryMap = {reposHost: targetUrl}
            cfg.target.user.addServerGlob(reposHost, targetUser, targetPass)

            cfg.source.repositoryMap = {reposHost: sourceUrl}
            cfg.source.user.addServerGlob(reposHost, sourceUser, sourcePass)

            cfg.host = reposHost

            if client.getOutboundMirrorAllLabels(sourceLabelId):
                cfg.labels = []
            else:
                cfg.labels = [versions.Label(project.getLabel())]

            cfg.configLine('matchTroves ' + ' '.join(client.getOutboundMatchTroves(sourceLabelId)))

            targetRepos = netclient.NetworkRepositoryClient(cfg.target.repositoryMap,
                                  cfg.target.user,
                                  entitlementDir = cfg.entitlementDirectory)

            sourceRepos = netclient.NetworkRepositoryClient(cfg.source.repositoryMap,
                                  cfg.source.user,
                                  entitlementDir = cfg.entitlementDirectory)

            while mirror.mirrorRepository(sourceRepos, targetRepos, cfg, False, False,
                                          False):
                pass

        return 0

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())

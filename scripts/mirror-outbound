#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
import os
from os import _exit

from conary.conaryclient import mirror
from conary import versions
from conary.repository import netclient
from conary.lib import util, log

from mint import config
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorOutbound(MirrorScript):
    logFileName = "mirror-outbound.log"

    def action(self):
        client = MintClient(sys.argv[1])

        mintCfg = config.MintConfig()
        mintCfg.read(config.RBUILDER_CONFIG)
        outboundMirrors = client.getOutboundMirrors()

        for outboundMirrorId, sourceProjectId, targetLabels, \
                allLabels, recurse, matchStrings, order in outboundMirrors:

            cfg = mirror.MirrorFileConfiguration()
            cfg.entitlementDirectory = None
            cfg.proxy = mintCfg.internalProxy or mintCfg.proxy

            sourceProject = client.getProject(int(sourceProjectId))
            sourceLabelId = sourceProject.getLabelIdMap().values()[0]
            self.log.info("Mirroring %s" % sourceProject.name)


            try:
                labelStr, _, sourceUser, sourcePass  = \
                          client.getLabel(sourceLabelId)
                reposHost = versions.Label(labelStr).getHost()
                cfg.host = reposHost
                sourceUrl = sourceProject.getConaryConfig().repositoryMap[reposHost]
                repositoryMap = client.getFullRepositoryMap()

                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(labelStr) for labelStr in targetLabels.split(" ")]
                cfg.configLine('matchTroves ' + ' '.join(matchStrings))

                sourceRepos = None
                targetRepos = []

                sourceCfg = cfg.setSection("source")
                sourceCfg.repositoryMap = repositoryMap.copy()
                sourceCfg.repositoryMap.update({reposHost: sourceUrl})
                sourceCfg.user.addServerGlob(reposHost, sourceUser, sourcePass)
                sourceRepos = netclient.NetworkRepositoryClient(sourceCfg.repositoryMap, sourceCfg.user, entitlementDir = cfg.entitlementDirectory)

                targetOrdinal = 0
                for _, targetUrl, targetUser, targetPass in \
                        client.getOutboundMirrorTargets(outboundMirrorId):
                    if cfg.hasSection("target"):
                        targetOrdinal += 1
                        targetCfg = cfg.setSection("target%d" % targetOrdinal)
                    else:
                        targetCfg = cfg.setSection("target")
                    targetCfg = cfg.setSection("target")
                    targetCfg.repositoryMap = repositoryMap.copy()
                    targetCfg.repositoryMap.update({reposHost: targetUrl})
                    targetCfg.user.addServerGlob(reposHost, targetUser, targetPass)
                    t = netclient.NetworkRepositoryClient(targetCfg.repositoryMap, targetCfg.user, entitlementDir = cfg.entitlementDirectory)
                    targetRepos.append(t)

                if not targetRepos:
                    self.log.warning("Skipping mirror of %s; no targets specified" % \
                            sourceProject.name)
                    continue

                tmpDir = os.path.join(mintCfg.dataPath, 'tmp')
                if os.access(tmpDir, os.W_OK):
                    util.settempdir(tmpDir)

                while mirror.mirrorRepository(sourceRepos, targetRepos, cfg, False, False,
                                              False):
                    pass
            except Exception, e:
                self.log.error("Exception mirroring %s" % sourceProject.name)
                self.logTraceback()
        return 0

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())

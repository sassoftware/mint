#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
import os
from os import _exit
import urllib
import xmlrpclib

from conary.conaryclient import mirror
from conary import conaryclient, conarycfg
from conary import dbstore
from conary import versions
from conary.repository import errors
from conary.lib import util, log

from mint import config
from mint import helperfuncs
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorOutbound(MirrorScript):
    logFileName = "mirror-outbound.log"

    def action(self):
        client = MintClient(self.args[0])

        outboundMirrors = client.getOutboundMirrors()

        # get proxy configuration here
        proxy = self.cfg.proxy

        mirrorMarks = {}

        for outboundMirrorId, sourceProjectId, targetLabels, \
                allLabels, recurse, matchStrings, order in outboundMirrors:

            cfg = mirror.MirrorFileConfiguration()
            cfg.entitlementDirectory = self.cfg.dataPath + '/entitlements/'

            sourceProject = client.getProject(int(sourceProjectId))
            sourceLabelId = sourceProject.getLabelIdMap().values()[0]
            self.log.info("Mirroring %s" % sourceProject.name)

            try:
                labelStr, _, sourceUser, sourcePass  = \
                          client.getLabel(sourceLabelId)
                reposHost = versions.Label(labelStr).getHost()
                cfg.host = reposHost
                sourceUrl = sourceProject.getConaryConfig().repositoryMap[reposHost]
                repositoryMap = client.getFullRepositoryMap()

                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(labelStr) for labelStr in targetLabels.split(" ")]
                cfg.configLine('matchTroves ' + ' '.join(matchStrings))
                cfg.recurseGroups = recurse

                sourceRepos = None
                targetRepos = []

                db = dbstore.connect(self.cfg.dbPath, self.cfg.dbDriver)
                cu = db.cursor()
                cu.execute("SELECT label, username, password FROM Labels")
                userData = cu.fetchall_dict()
                sourceCfg = cfg.setSection("source")
                sourceCfg.repositoryMap.update(repositoryMap.copy())
                sourceCfg.repositoryMap.update({reposHost: sourceUrl})
                for glob in userData:
                    sourceCfg.user.addServerGlob(versions.Label(glob['label']).getHost(),
                                        glob['username'], glob['password'])
                sourceCfg.user.addServerGlob(reposHost, sourceUser, sourcePass)

                sourceCCfg = conarycfg.ConaryConfiguration()
                sourceCCfg.repositoryMap.update(sourceCfg.repositoryMap)
                sourceCCfg.user = sourceCfg.user
                sourceCCfg.entitlementDirectory = cfg.entitlementDirectory
                sourceCCfg.readEntitlementDirectory()
                sourceCCfg.proxy = proxy
                sourceRepos = conaryclient.ConaryClient(sourceCCfg).getRepos()

                serverNames = []
                if recurse:
                    for x in matchStrings:
                        if x.startswith('+group-'):
                            group = x[1:]
                            break

                    self.log.info("Recursing %s..." % group)
                    groupVersions = sourceRepos.getTroveVersionList(versions.Label(labelStr).getHost(), {group:None})
                    jobList = []
                    for group, verDict in groupVersions.items():
                        for ver, flavorList in verDict.items():
                            for fl in flavorList:
                                #jobList.append((group, (None, None), (ver, fl),
                                #                True))
                                groupCs = sourceRepos.createChangeSet(
                                #         jobList,
                                    [(group, (None, None), (ver, fl), True)],
                                          withFiles=False, 
                                          withFileContents = False, 
                                          recurse = True)
                    for troveCs in groupCs.iterNewTroveList():
                        serverNames.append(troveCs.getNewNameVersionFlavor()[1].getHost())
                    serverNames = list(set(serverNames))

                targetOrdinal = 0
                for _, targetUrl, targetUser, targetPass in \
                        client.getOutboundMirrorTargets(outboundMirrorId):
                    _, url = urllib.splittype(targetUrl)
                    rapa_host, _ = urllib.splithost(url)

                    rapa_user = client.getrAPAPassword(rapa_host, 'serverNames')
                    if rapa_user:
                        try:
                            sp = xmlrpclib.ServerProxy('https://%s:%s@%s:8003/rAA/xmlrpc/' % (rapa_user[0], rapa_user[1], rapa_host))
                            sp.conaryserver.ConaryServer.addServerName(serverNames)
                        except:
                            raise
                    if cfg.hasSection("target"):
                        targetOrdinal += 1
                        targetCfg = cfg.setSection("target%d" % targetOrdinal)
                    else:
                        targetCfg = cfg.setSection("target")
                    targetCfg.repositoryMap.update(repositoryMap)
                    for x in serverNames:
                        targetCfg.repositoryMap.update({x:targetUrl})
                    targetCfg.user.addServerGlob('*', targetUser, targetPass)
                    for k in targetCfg.repositoryMap.keys():
                        targetCfg.repositoryMap[k] = targetUrl

                    targetCCfg = conarycfg.ConaryConfiguration()
                    targetCCfg.repositoryMap.update(targetCfg.repositoryMap)
                    targetCCfg.user = targetCfg.user
                    targetCCfg.entitlementDirectory = cfg.entitlementDirectory
                    targetCCfg.readEntitlementDirectory()
                    targetCCfg.proxy = proxy
                    t = conaryclient.ConaryClient(targetCCfg).getRepos()
                    targetRepos.append(t)

                    # If we have multiple sources for the same host,
                    # reset the mirror mark
                    try:
                        mm = t.getMirrorMark(reposHost)
                    except errors.OpenError:
                        # No mirrormark for reposHost on this target
                        mirrorMarks.update({targetUrl:{reposHost:-1}})
                    else:
                        if mirrorMarks.get(targetUrl):
                            oldMark = mirrorMarks[targetUrl].get(reposHost)
                            if oldMark and oldMark < mm:
                                t.setMirrorMark(reposHost, oldMark)
                            else:
                                mirrorMarks[targetUrl].update({reposHost:mm})
                        else:
                            mirrorMarks.update({targetUrl:{reposHost:mm}})
                            
                
                if not targetRepos:
                    self.log.warning("Skipping mirror of %s; no targets specified" % \
                            sourceProject.name)
                    continue

                self._doMirror(cfg, sourceRepos, targetRepos)

            except Exception, e:
                self.log.error("Exception mirroring %s" % sourceProject.name)
                self.logTraceback()
        return 0

    def cleanup(self):
        self.log.info("Outbound mirror script finished")

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())

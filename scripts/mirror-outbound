#!/usr/bin/python2.4
#
# Copyright (c) 2006 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
import os
from os import _exit

from conary.conaryclient import mirror
from conary import versions
from conary.repository import netclient
from conary.lib import util, log

from mint import config
from mint.client import MintClient
from mint.scriptlibrary import SingletonScript

log.setVerbosity(log.DEBUG)
sys.excepthook = util.genExcepthook(debug=True)

class MirrorOutbound(SingletonScript):
    cfgPath = config.RBUILDER_CONFIG

    cfg = config.MintConfig()
    cfg.read(cfgPath)
    logPath = os.path.join(cfg.dataPath, 'logs', "mirror-outbound.log")
    del cfg

    def handle_args(self):
        if len(sys.argv) < 2:
            return False
        return True

    def usage(self):
        print "usage: %s <url to rBuilder server>" % self.name
        return 1

    def action(self):
        client = MintClient(sys.argv[1])
        cfg = mirror.MirrorConfiguration()

        mirroredLabels = client.getOutboundMirrors()

        for label in mirroredLabels:
            outboundMirrorId, projectId, sourceLabels, targetUrl, \
                targetUser, targetPass, mirrorAll, recurse, matchStrings = label
            projectId = int(projectId)
            sourceProject = client.getProject(projectId)
            sourceLabelId = sourceProject.getLabelIdMap().values()[0]

            labelStr, _, sourceUser, sourcePass  = \
                      client.getLabel(sourceLabelId)
            reposHost = versions.Label(labelStr).getHost()
            sourceUrl = sourceProject.getConaryConfig().repositoryMap[reposHost]

            cfg.target.repositoryMap = {reposHost: targetUrl}
            cfg.target.user.addServerGlob(reposHost, targetUser, targetPass)

            cfg.source.repositoryMap = {reposHost: sourceUrl}
            cfg.source.user.addServerGlob(reposHost, sourceUser, sourcePass)

            cfg.host = reposHost

            if mirrorAll:
                cfg.labels = []
            else:
                cfg.labels = [versions.Label(labelStr)]

            cfg.configLine('matchTroves ' + ' '.join(matchStrings))


            targetRepos = netclient.NetworkRepositoryClient(cfg.target.repositoryMap,
                                  cfg.target.user,
                                  entitlementDir = cfg.entitlementDirectory)

            sourceRepos = netclient.NetworkRepositoryClient(cfg.source.repositoryMap,
                                  cfg.source.user,
                                  entitlementDir = cfg.entitlementDirectory)

            while mirror.mirrorRepository(sourceRepos, targetRepos, cfg, False, False,
                                          False):
                pass

        return 0

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())

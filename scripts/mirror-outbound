#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
import os
from os import _exit
import xmlrpclib

from conary.conaryclient import mirror
from conary import conaryclient, conarycfg
from conary import dbstore
from conary import trove
from conary import versions
from conary.repository import errors
from conary.lib import util, log

from mint import config
from mint import helperfuncs
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorOutbound(MirrorScript):
    logFileName = "mirror-outbound.log"

    def action(self):
        self.resetLogging()
        client = MintClient(self.args[0])

        outboundMirrors = client.getOutboundMirrors()

        # get proxy configuration here
        proxy = self.cfg.proxy

        mirrorMarks = {}

        for outboundMirrorId, sourceProjectId, targetLabels, \
                allLabels, recurse, matchStrings, order, \
                fullSync in outboundMirrors:

            cfg = mirror.MirrorFileConfiguration()

            sourceProject = client.getProject(int(sourceProjectId))
            sourceLabelId = sourceProject.getLabelIdMap().values()[0]
            self.log.info("Mirroring %s" % sourceProject.name)

            try:
                labelInfo = client.getLabel(sourceLabelId)
                labelStr = labelInfo['label']
                reposHost = versions.Label(labelStr).getHost()
                cfg.host = reposHost
                sourceUrl = sourceProject.getConaryConfig().repositoryMap[reposHost]
                repositoryMap = client.getFullRepositoryMap()

                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(labelStr) for labelStr in targetLabels.split(" ")]
                cfg.configLine('matchTroves ' + ' '.join(matchStrings))
                cfg.configLine('recurseGroups %s' % bool(recurse))

                sourceRepos = None
                targetRepos = []

                labelPath, repoMap, userMap, entMap = client.getAllLabelsForProjects()

                sourceCfg = cfg.setSection("source")
                sourceCfg.repositoryMap.update(repositoryMap)
                sourceCfg.repositoryMap.update({reposHost: sourceUrl})
                for host, authInfo in userMap:
                    sourceCfg.user.addServerGlob(host, authInfo[0], authInfo[1])
                for host, entitlement in entMap:
                    sourceCfg.entitlement.addEntitlement(host, entitlement[1])

                sourceCCfg = conarycfg.ConaryConfiguration()
                sourceCCfg.repositoryMap.update(sourceCfg.repositoryMap)
                sourceCCfg.user = sourceCfg.user
                sourceCCfg.entitlement = sourceCfg.entitlement
                sourceCCfg.proxy = proxy
                sourceRepos = conaryclient.ConaryClient(sourceCCfg).getRepos()

                obmt = client.getOutboundMirrorTargets(outboundMirrorId)
                if not obmt:
                    self.log.warning("Skipping %s, no Update Services specified" % \
                            sourceProject.name)
                    continue

                targetOrdinal = 0
                for _, hostname, targetUser, targetPass, _ in obmt:
                    targetUrl = 'https://%s/conary/' % hostname

                    if cfg.hasSection("target"):
                        targetOrdinal += 1
                        targetCfg = cfg.setSection("target%d" % targetOrdinal)
                    else:
                        targetCfg = cfg.setSection("target")
                    targetCfg.repositoryMap = []
                    targetCfg.configLine('repositoryMap * %s' % targetUrl)
                    targetCfg.user.addServerGlob('*', targetUser, targetPass)

                    targetCCfg = conarycfg.ConaryConfiguration()
                    targetCCfg.repositoryMap.update(targetCfg.repositoryMap)
                    targetCCfg.user = targetCfg.user
                    targetCCfg.proxy = proxy
                    t = conaryclient.ConaryClient(targetCCfg).getRepos()
                    targetRepos.append(t)

                try:
                    self._doMirror(cfg, sourceRepos, targetRepos, fullSync)
                finally:
                    if fullSync:
                        client.setOutboundMirrorSync(outboundMirrorId, False)
            except KeyboardInterrupt, ke:
                self.log.info("Outbound mirror killed by user")
                break
            except errors.InsufficientPermission, ie:
                self.log.error("%s. Check to make sure that you have been given access to mirror from the aforementioned repository." % ie)
            except Exception, e:
                self.log.error("Exception occurred while mirroring %s" % sourceProject.name)
                self.logTraceback()
        return 0

    def cleanup(self):
        self.log.info("Outbound mirror script finished")

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())

#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
import os
from os import _exit
import xmlrpclib

from conary.conaryclient import mirror
from conary import conaryclient, conarycfg
from conary import dbstore
from conary import trove
from conary import versions
from conary.deps import deps
from conary.repository import errors
from conary.lib import util, log

from mint import config
from mint import helperfuncs
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorOutbound(MirrorScript):
    logFileName = "mirror-outbound.log"

    def action(self):
        self.resetLogging()
        client = MintClient(self.args[0])

        outboundMirrors = client.getOutboundMirrors()

        # get proxy configuration here
        proxy = self.cfg.proxy

        mirrorMarks = {}

        for (outboundMirrorId, sourceProjectId, targetLabels, allLabels,
          recurse, matchStrings, order, fullSync, useReleases,
          ) in outboundMirrors:
            cfg = mirror.MirrorFileConfiguration()

            sourceProject = client.getProject(int(sourceProjectId))
            sourceLabelId = sourceProject.getLabelIdMap().values()[0]
            self.log.info("Mirroring %s" % sourceProject.name)

            try:
                labelInfo = client.getLabel(sourceLabelId)
                labelStr = labelInfo['label']
                cfg.host = reposHost = versions.Label(labelStr).getHost()

                sourceProjCCfg = sourceProject.getConaryConfig()
                sourceUrl = sourceProjCCfg.repositoryMap[reposHost]
                conaryProxy = sourceProjCCfg.conaryProxy
                repositoryMap = client.getFullRepositoryMap()

                # Note that the mirror role must be named differently so that
                # conary does not delete it when the user is deleted at the
                # end of the mirror process. Otherwise we lose the ACLs we
                # already ate the cost of adding.
                mirrorUser = 'mirror'
                mirrorRole = 'mirror-role'

                # Configure source
                sourceCfg = cfg.setSection("source")
                sourceCfg.repositoryMap.update(repositoryMap)
                sourceCfg.repositoryMap.update({reposHost: sourceUrl})
                cfg.setSection('') # Switch back to the main config

                # Add user/entitlement information from all projects
                labelPath, repoMap, userMap, entMap = client.getAllLabelsForProjects()
                for host, authInfo in userMap:
                    sourceCfg.user.addServerGlob(host, authInfo[0], authInfo[1])
                for host, entitlement in entMap:
                    sourceCfg.entitlement.addEntitlement(host, entitlement[1])

                # Get a repository client for the mirror function
                sourceCCfg = conarycfg.ConaryConfiguration()
                sourceCCfg.repositoryMap.update(sourceCfg.repositoryMap)
                sourceCCfg.user = sourceCfg.user
                sourceCCfg.entitlement = sourceCfg.entitlement
                sourceCCfg.proxy = proxy
                sourceCCfg.conaryProxy = conaryProxy

                # privRepos is a privileged netclient for managing the
                # mirror user and its permissions
                privRepos = sourceRepos = \
                    conaryclient.ConaryClient(sourceCCfg).getRepos()

                if useReleases:
                    # Using published release based mirroring
                    releases = client.getMirrorableReleasesByProject(
                        int(sourceProjectId))

                    # Get the list of troves that *should* be mirrored
                    newTroves = set()
                    for pubReleaseId in releases:
                        builds = client.getBuildsForPublishedRelease(
                          pubReleaseId)
                        for buildId in builds:
                            build = client.getBuild(buildId)
                            name = build.troveName
                            # troveVersion has a timestamp;
                            # listTroveAccess will not. "un-freeze"
                            #the version to make sure they match.
                            version = versions.ThawVersion(build.troveVersion)
                            flavor = deps.ThawFlavor(build.troveFlavor)
                            newTroves.add((name, version, flavor))

                    # we probably don't need matchTroves here anymore
                    # names = set('+' + x[0] for x in newTroves)
                    cfg.labels = []
                    # cfg.configLine('matchTroves ' + ' '.join(names))
                    cfg.configLine('recurseGroups True')
                    cfg.troveList = newTroves

                    # For now, always force a full sync, as older
                    # releases may have been added to the mirrorable
                    # list since the last mirror. Later we might be
                    # able to only force a sync if the oldest
                    # unmirrored group is newer than the oldest
                    # mirror mark, but this would require a new repos
                    # call (to get the trove timestamp).
                    fullSync = True
                else:
                    # Using label+group based mirroring
                    if allLabels:
                        cfg.labels = []
                    else:
                        cfg.labels = [versions.Label(labelStr) for labelStr in targetLabels.split(" ")]
                    cfg.configLine('matchTroves ' + ' '.join(matchStrings))
                    cfg.configLine('recurseGroups %s' % bool(recurse))

                # Configure targets
                obmt = client.getOutboundMirrorTargets(outboundMirrorId)
                if not obmt:
                    self.log.warning("Skipping %s, no Update Services specified" % \
                            sourceProject.name)
                    continue

                targetOrdinal = 0
                targetReposes = []
                for _, hostname, targetUser, targetPass, _ in obmt:
                    targetUrl = 'https://%s/conary/' % hostname

                    if cfg.hasSection("target"):
                        targetOrdinal += 1
                        targetCfg = cfg.setSection("target%d" % targetOrdinal)
                    else:
                        targetCfg = cfg.setSection("target")
                    targetCfg.repositoryMap = []
                    targetCfg.configLine('repositoryMap * %s' % targetUrl)
                    targetCfg.user.addServerGlob('*', targetUser, targetPass)

                    targetCCfg = conarycfg.ConaryConfiguration()
                    targetCCfg.repositoryMap.update(targetCfg.repositoryMap)
                    targetCCfg.user = targetCfg.user
                    targetCCfg.proxy = proxy
                    t = conaryclient.ConaryClient(targetCCfg).getRepos()
                    targetReposes.append(t)

                # Do the mirror
                try:
                    self._doMirror(cfg, sourceRepos, targetReposes, fullSync)
                finally:
                    if fullSync:
                        client.setOutboundMirrorSync(outboundMirrorId, False)

            except KeyboardInterrupt, ke:
                self.log.info("Outbound mirror killed by user")
                break
            except errors.InsufficientPermission, ie:
                self.log.error("%s. Check to make sure that you have been given access to mirror from the aforementioned repository." % ie)
            except Exception, e:
                self.log.error("Exception occurred while mirroring %s" % sourceProject.name)
                self.logTraceback()
        return 0

    def cleanup(self):
        self.log.info("Outbound mirror script finished")

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())

#!/usr/bin/python2.4
#
# Copyright (c) 2005-2007 rPath, Inc.
#
# All Rights Reserved
#

# This script is only used when the target mirror is in a DMZ and does not
# have permission/access to call back to the rBuilder Appliance to mirror.
# This script should be run from a machine with access to both rBA and mirror.

import sys
import os
from os import _exit
import urllib
import xmlrpclib

from conary.conaryclient import mirror
from conary import conaryclient, conarycfg
from conary import dbstore
from conary import trove
from conary import versions
from conary.repository import errors
from conary.lib import util, log

from mint import config
from mint import helperfuncs
from mint.client import MintClient
from mint.mirror import MirrorScript

log.setVerbosity(log.DEBUG)

class MirrorOutbound(MirrorScript):
    logFileName = "mirror-outbound.log"

    def action(self):
        self.resetLogging()
        client = MintClient(self.args[0])

        outboundMirrors = client.getOutboundMirrors()

        # get proxy configuration here
        proxy = self.cfg.proxy

        mirrorMarks = {}

        for outboundMirrorId, sourceProjectId, targetLabels, \
                allLabels, recurse, matchStrings, order, \
                fullSync in outboundMirrors:

            cfg = mirror.MirrorFileConfiguration()

            sourceProject = client.getProject(int(sourceProjectId))
            sourceLabelId = sourceProject.getLabelIdMap().values()[0]
            self.log.info("Mirroring %s" % sourceProject.name)

            try:
                labelInfo = client.getLabel(sourceLabelId)
                labelStr = labelInfo['label']
                reposHost = versions.Label(labelStr).getHost()
                cfg.host = reposHost
                sourceUrl = sourceProject.getConaryConfig().repositoryMap[reposHost]
                repositoryMap = client.getFullRepositoryMap()

                if allLabels:
                    cfg.labels = []
                else:
                    cfg.labels = [versions.Label(labelStr) for labelStr in targetLabels.split(" ")]
                cfg.configLine('matchTroves ' + ' '.join(matchStrings))
                cfg.configLine('recurseGroups %s' % bool(recurse))

                sourceRepos = None
                targetRepos = []

                labelPath, repoMap, userMap, entMap = client.getAllLabelsForProjects()

                sourceCfg = cfg.setSection("source")
                sourceCfg.repositoryMap.update(repositoryMap)
                sourceCfg.repositoryMap.update({reposHost: sourceUrl})
                serverNamesSet = set([reposHost])
                authHosts = set([reposHost])
                for host, authInfo in userMap:
                    sourceCfg.user.addServerGlob(host, authInfo[0], authInfo[1])
                    authHosts.add(host)
                for host, entitlement in entMap:
                    sourceCfg.entitlement.addEntitlement(host, entitlement[1])
                    authHosts.add(host)

                sourceCCfg = conarycfg.ConaryConfiguration()
                sourceCCfg.repositoryMap.update(sourceCfg.repositoryMap)
                sourceCCfg.user = sourceCfg.user
                sourceCCfg.entitlement = sourceCfg.entitlement
                sourceCCfg.proxy = proxy
                sourceRepos = conaryclient.ConaryClient(sourceCCfg).getRepos()

                obmt = client.getOutboundMirrorTargets(outboundMirrorId)
                if not obmt:
                    self.log.warning("Skipping mirror of %s; no targets specified" % \
                            sourceProject.name)
                    continue

                if recurse:
                    # XXX This entire body of code is really too slow, and doesn't need
                    # XXX to be done every single pass for group mirrors. Its only purpose
                    # XXX is to set up the rUS to accept the list of servernames needed
                    # XXX to properly mirror the group.
                    groups = client.getOutboundMirrorGroups(outboundMirrorId)
                    self.log.info("Mirroring the following groups %s" % groups)
                    for group in groups:
                        self.log.info("Recursing %s to find serverNames..." % group)
                        groupNVFs = []
                        groupVersions = sourceRepos.getTroveVersionList(reposHost, {group:None})
                        for n, verDict in groupVersions.items():
                            for v, flavorList in verDict.items():
                                if cfg.labels and v.trailingLabel() not in cfg.labels:
                                    continue
                                for f in flavorList:
                                    groupNVFs.append((n,v,f))

                        nDone = 0
                        for n1, v1, f1 in groupNVFs:
                            self.log.debug("Getting troveVersion for %s=%s[%s]" % (n,v,f))
                            groupCs = sourceRepos.createChangeSet(
                                [(n1, (None, None), (v1, f1), True)],
                                      withFiles=False,
                                      withFileContents = False,
                                      recurse = False)
                            tcs = groupCs.getNewTroveVersion(n1, v1, f1)
                            t = trove.Trove(tcs)
                            for n2, v2, f2 in t.iterTroveList(strongRefs=False, weakRefs=True):
                                serverNamesSet.add(v2.getHost())
                            nDone += 1
                            percentDone = int(float(nDone) / float(len(groupNVFs)) * 100.0)
                            if (nDone % 10) == 0:
                                self.log.info("Recursing %s to find serverNames (%d%% complete)" % (group, percentDone))

                serverNames = list(serverNamesSet)
                self.log.info("serverNames needed for mirroring: %s" % ', '.join(serverNames))

                # XXX This is a best-effort attempt to catch if we have servers we need to
                # contact during the course of mirroring where we didn't specify any
                # permissions, either via user or entitlements. It will miss cases where
                # filecontents are spread across two repositories, and it may warn
                # unnecessarily if the source repository has mirroring enabled for the
                # anonymous group. A more complete test would be too slow to run every
                # time, so this will have to do. --sgp
                neededHosts = serverNamesSet - authHosts
                for n in neededHosts:
                    self.log.warning("No authentication was given for server %s; this may cause problems when attempting to mirror troves from that server to the Update Service. Make sure that your rBuilder has an external project with this hostname set up with a valid user or entitlement with mirror permissions." % n)

                targetOrdinal = 0
                for _, targetUrl, targetUser, targetPass in obmt:
                    _, url = urllib.splittype(targetUrl)
                    rapa_host, _ = urllib.splithost(url)

                    if recurse:
                        rapa_user = client.getrAPAPassword(rapa_host, 'serverNames')
                        if rapa_user:
                            try:
                                sp = xmlrpclib.ServerProxy('https://%s:%s@%s:8003/rAA/xmlrpc/' % (rapa_user[0], rapa_user[1], rapa_host))
                                sp.conaryserver.ConaryServer.addServerName(serverNames)
                            except:
                                raise
                    if cfg.hasSection("target"):
                        targetOrdinal += 1
                        targetCfg = cfg.setSection("target%d" % targetOrdinal)
                    else:
                        targetCfg = cfg.setSection("target")
                    targetCfg.repositoryMap.update(repositoryMap)
                    for x in serverNames:
                        targetCfg.repositoryMap.update({x:targetUrl})
                    targetCfg.user.addServerGlob('*', targetUser, targetPass)

                    for k in targetCfg.repositoryMap.keys():
                        targetCfg.repositoryMap[k] = targetUrl

                    targetCCfg = conarycfg.ConaryConfiguration()
                    targetCCfg.repositoryMap.update(targetCfg.repositoryMap)
                    targetCCfg.user = targetCfg.user
                    targetCCfg.proxy = proxy
                    t = conaryclient.ConaryClient(targetCCfg).getRepos()
                    targetRepos.append(t)

                    # If we have multiple sources for the same host,
                    # reset the mirror mark
                    try:
                        mm = t.getMirrorMark(reposHost)
                    except errors.OpenError:
                        # No mirrormark for reposHost on this target
                        mirrorMarks.update({targetUrl:{reposHost:-1}})
                    else:
                        if mirrorMarks.get(targetUrl):
                            oldMark = mirrorMarks[targetUrl].get(reposHost)
                            if oldMark and oldMark < mm:
                                t.setMirrorMark(reposHost, oldMark)
                            else:
                                mirrorMarks[targetUrl].update({reposHost:mm})
                        else:
                            mirrorMarks.update({targetUrl:{reposHost:mm}})

                try:
                    self._doMirror(cfg, sourceRepos, targetRepos, fullSync)
                finally:
                    if fullSync:
                        client.setOutboundMirrorSync(outboundMirrorId, False)
            except KeyboardInterrupt, ke:
                self.log.info("Outbound mirror killed by user")
                break
            except errors.InsufficientPermission, ie:
                self.log.error("%s. Check to make sure that you have been given access to mirror from the aforementioned repository." % ie)
            except Exception, e:
                self.log.error("Exception occurred while mirroring %s" % sourceProject.name)
                self.logTraceback()
        return 0

    def cleanup(self):
        self.log.info("Outbound mirror script finished")

if __name__ == "__main__":
    mo = MirrorOutbound()
    _exit(mo.run())
